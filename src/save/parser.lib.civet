# parser.lib.civet

import {uni, esc} from 'unicode'
import {
	undef, defined, notdefined, assert, hash, hashof,
	isArray, isFunction, isString, isRegExp, isHash, isEmpty,
	} from 'datatypes'
import {
	getOptions, spaces, randomLabel, getLineAndColumn,
	allLinesInBlock,
	} from 'llutils'
import {resetOneIndent, splitLine} from 'indent'
import {OL} from 'to-nice'
import {DBG, INDENT, UNDENT} from 'logger'
import {findFile, allLinesIn} from 'fsys'

# ---------------------------------------------------------------------------

export type TRuleFunc = (str: string, pos: number) => number

export isRuleFunc := (x: unknown): x is TRuleFunc =>
	return (typeof x == 'function')

export class Rule
	type: string
	func: TRuleFunc
	label: string = randomLabel()
	lChildren: Rule[] = []

	constructor(type: string, func: TRuleFunc, lChildren: Rule[] = [])
		@type = type
		@func = func
		@lChildren = []

	next(str: string, pos: number): number
		return @func str, pos

# --- Anything that can be converted to a Rule

export type TLaxRule = RegExp | string | TRuleFunc | TLaxRule[] |
	[key: string | symbol]: TLaxRule

# --- This used to work
#     I want to allow a TLaxRule to possibly be an array or hash of TLaxRules
#     was: export type TLaxRule = RegExp | string | TRuleFunc | TLaxRule[] | hashof<TLaxRule>

export type TCallback = (rule: Rule, lMatches: string[]) => void

# ---------------------------------------------------------------------------
# --- Custom errors

export class ParseError < Error

	constructor(msg: string)
		super msg
		@name = 'ParseError'

# ---------------------------------------------------------------------------
# --- Returns a function that:
#        1. accepts a string
#        2. throws error on failure

export type TParser = (str: string) => void

export function getParser(
		laxRule: TLaxRule | TLaxRule[] | hashof<TLaxRule>,
		lCallbacks: TCallback[] = [],
		hOptions: hash = {}
		): TParser

	type opt =
		reSkip: RegExp
		partial: boolean

	{reSkip, partial} := getOptions<opt> hOptions,
		reSkip: /^\s+/
		partial: false

	# ..........................................................
	# function that skips reSkip, if defined

	skipIgnored: TRuleFunc := (str, pos): number =>

		lMatches := str.substring(pos).match reSkip
		if defined(lMatches)
			len := lMatches[0].length
			if len > 0
				DBG "#{len} chars skipped"
			return pos + len
		else
			return pos

	# ..........................................................
	# --- function that maps RegExp => Rule

	RegexMatcher := (re: RegExp): Rule =>

		return new Rule('r', (str, pos): number =>
			skipPos := skipIgnored str, pos
			lMatches := re.exec str.substring skipPos
			if lMatches == null
				throw new ParseError("RegExp Rule not matched")
			len := lMatches[0].length
			assert (len > 0), "Zero length in regex match"
			newPos := skipPos + len
			for cb of lCallbacks
				cb rule, lMatches
			return newPos
		)

	# ..........................................................
	# --- function that maps string => Rule

	StringMatcher := (substr: string): Rule =>

		return new Rule('s', (str, pos): number =>
			skipPos := skipIgnored str, pos
			if not str.startsWith(substr, skipPos)
				throw new ParseError("String Rule not matched")
			len := substr.length
			assert (len > 0), "Zero length in regex match"
			newPos := skipPos + len
			for cb of lCallbacks
				cb rule, [substr]
			return newPos
		)

	# ..........................................................
	# --- function that maps TRuleFunc => Rule

	FuncMatcher := (func: TRuleFunc): Rule =>

		return new Rule('f', (str, pos): number =>
			skipPos := skipIgnored str, pos
			newPos := func str, skipPos
			assert (newPos > pos), "Zero length in rule match"
			for cb of lCallbacks
				cb rule, [str.substring(pos, newPos)]
			return newPos
		)

	# ..........................................................
	# --- function that maps TLaxRule => Rule

	getRule := (laxRule: TLaxRule | TLaxRule[] | hashof<TLaxRule>): Rule =>

		if isRegExp(laxRule)
			return RegexMatcher laxRule
		else if isString(laxRule)
			return StringMatcher laxRule
		else if isRuleFunc(laxRule)
			return FuncMatcher laxRule
		else if isArray(laxRule)
			return All laxRule
		else
			return Any laxRule

	# ..........................................................
	# --- function that maps TLaxRule[] => Rule

	Any := (hItems: hashof<TLaxRule>): Rule =>

		results := []
		for key in hItems
			val := hItems[key]
			rule := getRule val as TLaxRule
			rule.label = key
			results.push rule
		lRules := results
		return new Rule('|', (str, pos): number =>
			# --- Try each rule
			#     if any succeed, succeed & return new pos
			#     else throw error
			for rule of lRules
				try
					newPos := rule.next str, pos
					for cb of lCallbacks
						cb rule, [str.substring(pos, newPos)]
					return newPos
			throw new ParseError("Any Rule not matched")
		)

	# ..........................................................
	# --- function that maps TLaxRule[] => Rule

	All := (lLaxRules: TLaxRule[]): Rule =>

		results1 := []
		for laxRule of lLaxRules
			results1.push getRule laxRule
		lRules := results1
		return new Rule('&', (str, pos): number =>
			for rule of lRules
				try
					newPos := rule.next str, pos
					pos = newPos
				catch err
					throw new ParseError("All Rule not matched")
			for cb of lCallbacks
				cb rule, []
			return pos
		)

	# --- Return a function that throws an error
	#     if string doesn't parse

	rule := getRule laxRule

	return (str): boolean =>

		DBG "Parse #{esc(str)}", INDENT
		try
			endPos := rule.next str, 0
			DBG "endPos = #{endPos}"
			if (endPos == str.length) || partial
				DBG UNDENT
				return true
			finalPos := skipIgnored str, endPos
			DBG "finalPos = #{finalPos}", UNDENT
			if finalPos != str.length
				throw new ParseError("Not all input exhausted")
			return true
		catch err
			DBG UNDENT
			throw err
