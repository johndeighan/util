# var-free.lib.test.civet

import {
	mapper, syncMapper, reducer, syncReducer,
	ITERATOR, ASYNC_ITERATOR,
	} from 'var-free'
import {getFakeData, equal} from 'unit-test'

# ---------------------------------------------------------------------------
# --- test syncMapper()

(() =>
	lNums := [1, 2, 3, 4]

	# --- pure mapping

	lItems := syncMapper lNums, (n) ->
		yield "number is #{n}"

	equal Array.from(lItems), [
		"number is 1"
		"number is 2"
		"number is 3"
		"number is 4"
		]
	)()

(() =>
	# --- pure mapping, early abort
	lItems := [1, 2, 3, 4]

	func := (i: number) ->
		yield "number is #{i}"
		if (i == 2)
			return
	abort_func := (i: number) ->
		return (i == 3)
	lNewItems := Array.from syncMapper lItems, func, abort_func

	equal lNewItems, [
		"number is 1"
		"number is 2"
		]
	)()

(() =>
	# --- pure mapping, using a generator

	gen := (): ITERATOR<number> ->
		for i of [1..4]
			yield i
		return

	lNewItems := Array.from syncMapper gen(), (n) ->
		yield "number is #{n}"

	equal lNewItems,
		[
			"number is 1"
			"number is 2"
			"number is 3"
			"number is 4"
			]
	)()

(() =>
	# --- pure filtering

	lItems := [1, 2, 3, 4]
	lNewItems := Array.from syncMapper lItems, (i: number) ->
		if (i % 2 == 0)
			yield i

	equal lNewItems, [2, 4]
	)()

(() =>
	# --- pure filtering, early abort

	func := (n: number) ->
		if (n % 2 == 0)
			yield n
	abortFunc := (i: number) ->
		return (i == 3)
	lItems := Array.from syncMapper [1,2,3,4,5,6], func, abortFunc

	equal lItems, [2]
	)()

(() =>
	# --- combined filtering and mapping

	lItems := Array.from syncMapper [1,2,3,4], (i: number) ->
		if (i % 2 == 0)
			yield "2i = #{2*i}"
			yield "number is #{10 * i}"
		return

	equal lItems,
		[
			"2i = 4"
			"number is 20"
			"2i = 8"
			"number is 40"
			]
	)()

# ---------------------------------------------------------------------------
# --- test syncReducer()

(() =>
	# --- reducing (getting the sum, use JavaScript's reduce)

	sum := [1,2,3,4].reduce (acc, n) => acc + n, 0
	equal sum, 10
	)()

(() =>
	# --- reducing (getting the sum)

	sum := syncReducer [1,2,3,4], 0, (acc, n) => acc + n
	equal sum, 10
	)()

(() =>
	# --- reducing (getting the sum, early abort)

	sum := syncReducer [1,2,3,4], 0,
			(acc,n) => acc+n,
			(n) -> return (n==3)
	equal sum, 3
	)()

(() =>
	# --- reducing (getting the sum AND sum of squares)

	type TAcc = [number, number]
	func := (accum: TAcc, n: number): TAcc =>
		[sum, sumsq] := accum
		return [sum + n, sumsq + n*n]

	[sum, sumsq] := syncReducer [1,2,3,4], [0, 0], func
	equal sum, 10
	equal sumsq, 30
	)()

(() =>
	# --- reducing
	#     (getting the sum AND sum of squares of only even nums)

	type TAcc = [number, number]
	func := (accum: TAcc, n: number): TAcc =>
		if (n % 2 == 0)
			[sum, sumsq] := accum
			return [sum + n, sumsq + n*n]
		else
			return accum

	[sum, sumsq] := syncReducer [1,2,3,4], [0, 0], func
	equal sum, 6
	equal sumsq, 20
	)()

# ---------------------------------------------------------------------------
# --- test mapper()

(() =>
	# --- pure mapping

	# --- an async iterator of integers
	iterData := getFakeData [1,2,3,4]

	# --- an async iterator of strings
	iterStrings := mapper iterData, (n) -> yield "number is #{n}"

	equal await Array.fromAsync(iterStrings), [
		"number is 1"
		"number is 2"
		"number is 3"
		"number is 4"
		]
	)()

# ---------------------------------------------------------------------------

