# temp.civet

import {
	mapper, syncMapper, reducer, syncReducer,
	Iter, AsyncIter,
	} from 'var-free'
import {generateAsync, equal} from 'unit-test'

# ---------------------------------------------------------------------------
# --- test syncMapper()

(() =>
	lNums := [1..4]

	# --- pure mapping

	lItems := syncMapper lNums, (n) ->
		yield "number is #{n}"

	equal Array.from(lItems), [
		"number is 1"
		"number is 2"
		"number is 3"
		"number is 4"
		]
	)()

(() =>
	# --- pure mapping, early abort
	lItems := [1..4]

	mapFunc := (n: number) ->
		yield "number is #{n}"

	abortFunc := (i: number) ->
		return (i == 3)

	lNewItems := Array.from syncMapper lItems, mapFunc, abortFunc

	equal lNewItems, [
		"number is 1"
		"number is 2"
		]
	)()

(() =>
	# --- pure mapping, using a generator

	gen := (): Iter<number> ->
		for i of [1..4]
			yield i
		return

	lNewItems := Array.from syncMapper gen(), (n) ->
		yield "number is #{n}"

	equal lNewItems,
		[
			"number is 1"
			"number is 2"
			"number is 3"
			"number is 4"
			]
	)()

(() =>
	# --- pure filtering

	lItems := [1..4]
	lNewItems := Array.from syncMapper lItems, (i: number) ->
		if (i % 2 == 0)
			yield i

	equal lNewItems, [2, 4]
	)()

(() =>
	# --- pure filtering, early abort

	func := (n: number) ->
		if (n % 2 == 0)
			yield n
	abortFunc := (i: number) ->
		return (i == 3)
	lItems := Array.from syncMapper [1..6], func, abortFunc

	equal lItems, [2]
	)()

(() =>
	# --- combined filtering and mapping

	lItems := Array.from syncMapper [1..4], (i: number) ->
		if (i % 2 == 0)
			yield "2i = #{2*i}"
			yield "number is #{10 * i}"
		return

	equal lItems,
		[
			"2i = 4"
			"number is 20"
			"2i = 8"
			"number is 40"
			]
	)()

# ---------------------------------------------------------------------------
# --- test syncReducer()

(() =>
	# --- reducing (getting the sum, use JavaScript's reduce)

	sum := [1..4].reduce (acc, n) => acc + n, 0
	equal sum, 10
	)()

(() =>
	# --- reducing (getting the sum)

	sum := syncReducer [1..4], 0, (acc, n) => acc + n
	equal sum, 10
	)()

(() =>
	# --- reducing (getting the sum, early abort)

	sum := syncReducer [1,2,3,4], 0,
			(acc,n) => acc+n,
			(n) -> return (n==3)
	equal sum, 3
	)()

(() =>
	# --- reducing (getting the sum AND sum of squares)

	type TAcc = [number, number]
	func := (accum: TAcc, n: number): TAcc =>
		[sum, sumsq] := accum
		return [sum + n, sumsq + n*n]

	[sum, sumsq] := syncReducer [1..4], [0, 0], func
	equal sum, 10
	equal sumsq, 30
	)()

(() =>
	# --- reducing
	#     (getting the sum AND sum of squares of only even nums)

	type TAcc = [number, number]
	func := (accum: TAcc, n: number): TAcc =>
		if (n % 2 == 0)
			[sum, sumsq] := accum
			return [sum + n, sumsq + n*n]
		else
			return accum

	[sum, sumsq] := syncReducer [1..4], [0, 0], func
	equal sum, 6
	equal sumsq, 20
	)()

# ---------------------------------------------------------------------------
# --- test mapper()

(() =>
	# --- pure mapping

	# --- an async iterator of integers
	iterData := generateAsync [1..4]

	# --- a mapping function
	mapFunc := (n: number) ->
		yield "number is #{n}"

	abortFunc := (i: number) ->
		return (i == 3)

	# --- an async iterator of strings
	iterStrings := mapper iterData, mapFunc, abortFunc

	equal await Array.fromAsync(iterStrings), [
		"number is 1"
		"number is 2"
		]
	)()

(() =>
	# --- pure mapping, early abort

	# --- an async iterator of integers
	iterData := generateAsync [1..4]

	mapFunc := (n: number) ->
		yield "number is #{n}"

	# --- an async iterator of strings
	iterStrings := mapper iterData, mapFunc

	equal await Array.fromAsync(iterStrings), [
		"number is 1"
		"number is 2"
		"number is 3"
		"number is 4"
		]
	)()

(() =>
	# --- pure filtering

	# --- an async iterator of integers
	iterData := generateAsync [1..4]
	lItems := mapper iterData, (n: number) ->
		if (n % 2 == 0)
			yield n
		return

	equal await Array.fromAsync(lItems), [2, 4]
	)()

(() =>
	# --- pure filtering, early abort

	# --- an async iterator of integers
	iterData := generateAsync [1..4]

	abortFunc := (n: number) ->
		return (n == 3)

	iterNum := mapper iterData, (n: number) ->
		if (n % 2 == 0)
			yield n
		return

	equal await Array.fromAsync(iterNum), [2, 4]
	)()

(() =>
	# --- combined filtering and mapping

	# --- an async iterator of integers
	iterData := generateAsync [1..4]

	abortFunc := (n: number) ->
		return (n == 3)

	mapFunc := (n: number) ->
		if (n % 2 == 0)
			yield "2n = #{2*n}"
			yield "number is #{10 * n}"
		return

	iterStr := mapper [1,2,3,4], mapFunc, abortFunc

	equal await Array.fromAsync(iterStr),
		[
			"2n = 4"
			"number is 20"
			]
	)()

# ---------------------------------------------------------------------------
# --- test reducer()

(() =>
	# --- reducing (getting the sum)

	reduceFunc := (acc: number, n: number): number ->
		return acc + n

	sum := await reducer generateAsync([1..4]), 0, reduceFunc
	equal sum, 10
	)()

(() =>
	# --- reducing (getting the sum, early abort)

	sum := await reducer [1..4], 0,
			(acc,n) => acc+n,
			(n) -> return (n==3)
	equal sum, 3
	)()

(() =>
	# --- reducing (getting the sum AND sum of squares)

	type TAcc = [number, number]
	func := (accum: TAcc, n: number): TAcc =>
		[sum, sumsq] := accum
		return [sum + n, sumsq + n*n]

	[sum, sumsq] := await reducer [1..4], [0, 0], func
	equal sum, 10
	equal sumsq, 30
	)()

(() =>
	# --- reducing
	#     (getting the sum AND sum of squares of only even nums)

	type TAcc = [number, number]
	func := (accum: TAcc, n: number): TAcc =>
		if (n % 2 == 0)
			[sum, sumsq] := accum
			return [sum + n, sumsq + n*n]
		else
			return accum

	[sum, sumsq] := await reducer [1..4], [0, 0], func
	equal sum, 6
	equal sumsq, 20
	)()

# ---------------------------------------------------------------------------
