# hera-compile.lib.civet

import {statSync} from 'node-fs'
import {existsSync} from '@std/fs'

import {uni, esc} from 'unicode'
import {
	undef, defined, notdefined, assertIsDefined,
	assert, croak, hash, isEmpty, nonEmpty,
	} from 'datatypes'
import {
	allLinesInBlock, arrayToBlock, getOptions,
	f, sep, pass, untabify, getErrStr,
	} from 'llutils'
import {resetOneIndent, splitLine, indented} from 'indent'
import {debugging} from 'cmd-args'
import {ML} from 'to-nice'
import {fileExt, withExt, isValidStub, pathStr} from 'fsys'
import {
	execCmd, CFileHandler, TExecResult,
	procFiles, doUnitTest,
	} from 'exec'

# ---------------------------------------------------------------------------

export class CHeraCompiler extends CFileHandler

	get op()
		return 'doCompileHera'

	override handle(
			path: string,
			hOptions: hash = {}
			): TExecResult

		assert (fileExt(path) == '.hera'), "Not a hera file"
		destPath := withExt path, '.ts'
		if (
				   not hOptions.force
				&& existsSync(destPath)
				&& (statSync(destPath).mtimeMs > statSync(path).mtimeMs)
				)
			return {success: true}

		try
			inProc := (str: string): string =>
				return compileHera str, hOptions

			outProc := (str: string): string =>
				return '#@ts-nocheck\n' + str.replaceAll('@danielx', 'npm:@danielx')

			hResult := await execCmd 'deno', [
				'run'
				'-A'
				'npm:@danielx/hera'
				'--module'
			], {
				infile: path
				inProc
				outfile: destPath
				outProc
				}
			assert hResult.success, "FAILED"
			assert existsSync(destPath), "Missing file: #{destPath}"
			return hResult

		catch err
			if debugging
				console.log getErrStr(err)
			errMsg := "HERA COMPILE FAILED: #{pathStr(path)} - #{getErrStr(err)}"
			return {
				success: false
				stderr: errMsg
				output: errMsg
				}

export doCompileHera := new CHeraCompiler()

# ---------------------------------------------------------------------------

export isRuleName := (name: string): boolean =>

	return defined(name.match /^[A-Za-z$_][A-Za-z0-9$_-]*$/)

# ---------------------------------------------------------------------------
# --- 1. Convert TAB chars to 2 spaces
#     2. if debug is set:
#           - add debugHeader block
#           - add "ruleMatch('<rule name>', $loc);" to start of each rule
#     3. output any lines within ``` as is

export debugHeader := """
	```
	import {CParseMatches} from 'parse-utils';
	export let pm = new CParseMatches();
	let ruleMatch = (
			name: string,
			loc: [pos: number, length: number]
			): void => {
		pm.match(name, loc);
		}
	```
	"""

export compileHera := (
		code: string,
		hOptions: hash = {}
		): string =>

	type opt = {
		debug: boolean
		compile: boolean
		}
	{debug, compile} := getOptions<opt> hOptions, {
		debug: false
		compile: false
		}

	type TState = 'main' | 'inBlock' | 'inRule' | 'inHandler'

	let curState = 'main'
	let curRuleName: string = ''

	isComment := (line: string): boolean =>

		return defined(line.match(/^\s*\#/))

	# ==========================================================

	lLines: string[] := debug ? [untabify(debugHeader, '  ')] : []

	output := (
			str: string,
			level: number = 0
			): void =>
		lLines.push '  '.repeat(level) + str.replaceAll('\t', '  ')
		return

	# ==========================================================

	lBlock: string[] := []

	startBlock := (): void =>

		lBlock.length = 0
		curState = 'inBlock'
		return

	# ----------------------------------------------------------

	addBlockCode := (line: string): void =>

		lBlock.push line

	# ----------------------------------------------------------

	endBlock := (): void =>

		output '```'
		output arrayToBlock(lBlock)
		output '```'
		curState = 'main'
		return

	# ==========================================================

	startRule := (name: string): void =>

		assert nonEmpty(name), "Empty rule name"
		curRuleName = name
		output name
		lHandler.length = 0
		addHandlerCode "ruleMatch('#{name}', $loc)"
		curState = 'inRule'
		return

	# --------------------------------------------

	endRule := (): void =>

		curRuleName = ''
		curState = 'main'
		return

	# ==========================================================

	lHandler: string[] := []

	startHandler := (matchStr: string): void =>

		assert nonEmpty(curRuleName), "Empty rule name"
		if debug && not matchStr.endsWith('->')
			output f"#{matchStr} ->", 1
		else
			output matchStr, 1
		lHandler.length = 0
		curState = 'inHandler'
		return

	# --------------------------------------------

	addHandlerCode := (str: string, level: number=0): void =>

		lHandler.push '  '.repeat(level) + str
		return

	# --------------------------------------------

	endHandler := (): void =>

		if nonEmpty(lHandler)
			block := arrayToBlock lHandler
			output indented(block, 2, {oneIndent: '  '})
		lHandler.length = 0
		return

	# ==========================================================

	resetOneIndent()
	for line of allLinesInBlock(code)

		# --- These are output regardless of the state we're in
		if line.match /^\s*\#/
			output (curState == 'inHandler') || (curState == 'inBlock') ? line.replace('#', '//') : line
			continue

		[level, str] := splitLine line   # --- str is trimmed
		switch curState

			when 'main'
				if isEmpty(line)
					output ''
				else if isComment(line)
					output line
				else if (line == '```')
					startBlock()
				else if isRuleName(str)
					assert (level == 0), f"Invalid rule name: #{line}:!"
					startRule str
				else
					croak f"Invalid rule Name: #{line}:!"

			when 'inBlock'
				if isEmpty(line)
					addBlockCode ''
				else if (line == '```')
					endBlock()
				else
					addBlockCode line

			when 'inRule'
				if isEmpty(line)
					output ''
				else if isComment(line)
					output line
				else
					# --- expect a match string
					assert (level == 1), f"Invalid match string: #{line}:!"
					startHandler(str)

			when 'inHandler'
				if isEmpty(line)
					addHandlerCode ''
				else
					switch level
						when 0
							endHandler()
							startRule str
						when 1
							endHandler()
							startHandler str
						else
							addHandlerCode str, level-2
	if (curState == 'inHandler')
		endHandler()

	return lLines.join '\n'

