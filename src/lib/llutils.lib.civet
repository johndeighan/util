# llutils.lib.civet

type AutoPromise<T> = Promise<Awaited<T>>
import {stripAnsiCode} from 'jsr:@std/fmt/colors'
import {createRequire} from 'node:module'
import {sprintf} from 'jsr:@std/fmt/printf'
import {relative} from 'jsr:@std/path'
import {existsSync} from 'jsr:@std/fs'
import {statSync} from 'node:fs'
import {parse: parseYAML} from "jsr:@std/yaml";

import {esc} from 'unicode'
import {
	undef, defined, notdefined, assert, char, deepEqual,
	assertIsDefined, isHash, isArray, isNonEmptyString,
	isArrayOfStrings, isEmpty, nonEmpty, isString, isInteger,
	integer, hash, hashof, array, arrayof, TVoidFunc, isNonPrimitive,
	functionDef, croak, assertIsString, assertIsNumber,
	TStringMapper,
	} from 'datatypes'

llutilsLoadTime: integer := Date.now()

# ---------------------------------------------------------------------------

export stdChecks := (helpStr: string = ''): void =>

	debugger
	root := Deno.env.get('PROJECT_ROOT_DIR')
	assert nonEmpty(root), "Please set env var PROJECT_ROOT_DIR"
	return

# ---------------------------------------------------------------------------

type TStringSource = Uint8Array<ArrayBuffer> | BufferSource | string

decoder := new TextDecoder()
export decode := (x: TStringSource): string =>
	return (typeof x == 'string') ? x : decoder.decode(x)

encoder := new TextEncoder()
export encode := (x: string): Uint8Array<ArrayBuffer> =>
	return encoder.encode x

# ---------------------------------------------------------------------------

export sinceLoad := (datetime: Date | integer = Date.now()): number =>

	if (datetime instanceof Date)
		return datetime.valueOf() - llutilsLoadTime
	else
		return datetime - llutilsLoadTime

# ---------------------------------------------------------------------------

export sinceLoadStr := (datetime: (Date | integer)? = undef) =>

	return sprintf "%6d", sinceLoad(datetime)

# ---------------------------------------------------------------------------

export throwsError := (
		func: TVoidFunc,
		msg: string = "Unexpected success"
		): void =>

	try
		func()
		throw new Error(msg)
	catch err
		return
# ignore error - it was expected

# ---------------------------------------------------------------------------

export pass := (): void =>
	# do nothing

# ---------------------------------------------------------------------------

export truncStr := (str: string, len: number) =>

	if str.length <= len
		return str
	return str.substring(0, len - 3) + '...'

# ---------------------------------------------------------------------------

export strToHash := (str: string): hash =>

	if isEmpty(str)
		return {}
	h: hash := {}
	for word of str.trim().split(/\s+/)
		let ref: string[] | null
		if (ref = word.match(/^(\!)?([A-Za-z][A-Za-z_0-9]*)(?:(=)(.*))?$/))
			lMatches: string[] | null := ref
			[_, neg, ident, eqSign, str] := lMatches
			if isNonEmptyString(eqSign)
				assert notdefined(neg) || (neg == ''),
						"negation with string value"
				# --- check if str is a valid number
				if str.match(/^-?\d+(\.\d+)?$/)
					num := parseFloat str
					if Number.isNaN(num)
						# --- TO DO: interpret backslash escapes
						h[ident] = str
					else
						h[ident] = num
				else
					h[ident] = str
			else if neg
				h[ident] = false
			else
				h[ident] = true
		else
			croak "Invalid word #{word}"
	return h

# ---------------------------------------------------------------------------

export o := (lStrings: TemplateStringsArray): hash =>

	return strToHash lStrings[0]

# ---------------------------------------------------------------------------

export s := (lStrings: TemplateStringsArray): string =>

	replacer := (match: string): string =>
		return '   '.repeat match.length
	return lStrings[0].replaceAll /^\t+/mg, replacer

# ---------------------------------------------------------------------------

export t := (lStrings: TemplateStringsArray): string =>

	replacer := (match: string): string =>
		level := Math.floor match.length / 3
		return '\t'.repeat level
	return lStrings[0].replaceAll /^\x20+/mg, replacer

# ---------------------------------------------------------------------------

export fsplit := (str: string): [string, number, boolean] =>

	lMatches := str.match(/^:(\!)?(\d+)?(.*)$/)
	if defined(lMatches)
		[_, escape, width, rest] := lMatches
		return [
			rest
			width ? parseInt(width) : 0
			nonEmpty(escape)
			]
	else
		return [str, 0, false]

# ---------------------------------------------------------------------------
# --- Number of strings is always 1 greater than the number of values

export f := (
		lStrings: TemplateStringsArray
		...lValues: unknown[]
		): string =>

	lParts: string[] := [lStrings[0]]
	for val,i of lValues
		[nextStr, width, escape] := fsplit lStrings[i+1]
		lParts.push (
			switch typeof val
				when 'string'
					valStr := escape ? esc(val) : val
					width ? sprintf("%-#{width}s", valStr) : valStr
				when 'number'
					if (width == 0)
						val.toString()
					else if Number.isInteger(val)
						sprintf("%#{width}d", val)
					else
						sprintf("%#{width}.2f", val)
				else
					valStr := JSON.stringify(val)
					width ? sprintf("%-s#{width}", valStr) : valStr
			)
		lParts.push nextStr
	return lParts.join('')

# ---------------------------------------------------------------------------

export type THashEntry = [key: string, val: unknown]

export type TEntryFilter = (
		entry: THashEntry
		) => boolean

export filterHash := (h: Object, func: TEntryFilter): hash =>

	return Object.fromEntries(
		Object.entries(h).filter(func)
		)

# ---------------------------------------------------------------------------

export removeEmptyKeys := (h: hash): hash =>

	func := (entry: THashEntry) =>
		[key, val] := entry
		return defined(val)
	return filterHash(h, func)

# ---------------------------------------------------------------------------

export keys = Object.keys
export hasOwn := Object.hasOwn

# ---------------------------------------------------------------------------

export numKeys := (h: hash): number =>

	return keys(h).length

# ---------------------------------------------------------------------------

export hasKey := (obj: unknown, ...lKeys: string[]) =>

	if (typeof obj != 'object') || (obj == null)
		return false
	for key of lKeys
		if not (key in obj)
			return false
	return true

export hasKeys := hasKey

# ---------------------------------------------------------------------------

export missingKeys := (h: hash, ...lKeys: string[]): string[] =>
	if notdefined(h)
		return lKeys
	assert isHash(h), "h not a hash: #{h}"
	lMissing: string[] := []
	for key of lKeys
		if not h.hasOwnProperty(key)
			lMissing.push key
	return lMissing

# ---------------------------------------------------------------------------

export merge := (...lObjects: hash[]): hash =>
	return Object.assign {}, ...lObjects

# ---------------------------------------------------------------------------

export hit := (pct: number = 50): boolean =>
	return (100 * Math.random() < pct)

# ---------------------------------------------------------------------------

# --- ASYNC !
export sleep := async (sec: number): AutoPromise<void> =>
	await new Promise((r) => setTimeout r, 1000 * sec)
	return

# ---------------------------------------------------------------------------

export sleepSync := (sec: number): void =>
	start := Date.now()
	end := Date.now() + 1000 * sec
	while Date.now() < end
	return

# ---------------------------------------------------------------------------

export spaces := (n: number): string =>
	return if (n <= 0) then '' else ' '.repeat(n)

# ---------------------------------------------------------------------------

export tabs := (n: number): string =>
	return if (n <= 0) then '' else '\t'.repeat(n)

# ---------------------------------------------------------------------------

export rtrim := (line: string): string =>
	assert isString(line), "not a string: #{typeof line}"
	lMatches := line.match /^(.*?)\s+$/
	return if (lMatches == null) then line else lMatches[1]

# ---------------------------------------------------------------------------

export countChars := (str: string, ch: string): number =>
	let count = 0
	let pos = -1
	while (pos = str.indexOf(ch, pos + 1)) != -1
		count += 1
	return count

# ---------------------------------------------------------------------------

export blockToArray := (block: string): string[] =>
	if isEmpty(block)
		return []
	else
		return block.split /\r?\n/

# ---------------------------------------------------------------------------

export mapEachLine := (block: string, mapper: TStringMapper) =>

	results := []
	for line of allLinesInBlock(block)
		results.push mapper line
	lLines := results
	return lLines.join '\n'

# ---------------------------------------------------------------------------

export type TBlockSpec = string | string[]
export isBlockSpec := (x: unknown): x is TBlockSpec =>
	return isString(x) || isArrayOfStrings(x)

# ---------------------------------------------------------------------------

export toArray := (strOrArray: TBlockSpec): string[] =>
	if Array.isArray(strOrArray)
		return strOrArray
	else
		return blockToArray strOrArray

# ---------------------------------------------------------------------------

export arrayToBlock := (lLines: string[]): string =>
	assert isArray(lLines), "lLines is not an array: #{lLines}"
	return lLines.filter((line) => defined line).join "\n"

# ---------------------------------------------------------------------------

export toBlock := (strOrArray: TBlockSpec): string =>
	if isString(strOrArray)
		return strOrArray
	else
		return arrayToBlock strOrArray

# ---------------------------------------------------------------------------

export invertHash := (h: hash): hash =>
	assert isHash(h), "Not a hash: #{h}"
	hResult: hash := {}
	for key of keys(h)
		value := h[key]
		if isString(value)
			hResult[value] = key
	return hResult

# ---------------------------------------------------------------------------

export wsSplit := (str: string): string[] =>
	newstr := str.trim()
	if newstr == ''
		return []
	else
		return newstr.split /\s+/

# ---------------------------------------------------------------------------

export words := (...lStrings: string[]): string[] =>
	lWords := []
	for str of lStrings
		for word of wsSplit(str)
			lWords.push word
	return lWords

# ---------------------------------------------------------------------------

export getNExtra := (str: string, len: number): number =>
	extra := len - str.length
	return if (extra > 0) then extra else 0

# ---------------------------------------------------------------------------

export rpad := (str: string, len: number, ch: string = ' '): string =>
	assert (ch.length == 1), "Not a char"
	extra := getNExtra str, len
	return str + ch.repeat(extra)

# ---------------------------------------------------------------------------

export lpad := (str: string, len: number, ch: string = ' '): string =>
	assert (ch.length == 1), "Not a char"
	extra := getNExtra str, len
	return ch.repeat(extra) + str

# ---------------------------------------------------------------------------

export type TAlignment = 'l' | 'c' | 'r' | 'left' | 'center' | 'right'
export isAlignment := (x: unknown): x is TAlignment =>
	return ((typeof x == 'string') && ['l', 'c', 'r', 'left', 'center', 'right'].includes(x))
export alignString := function(str: string, width: number, align: TAlignment): string
	switch align
		case 'left':
		case 'l':
			return rpad str, width
		case 'center':
		case 'c':
			return sep ' ', str, width
		case 'right':
		case 'r':
			return lpad str, width

# ---------------------------------------------------------------------------

export zpad := (n: number, len: number): string =>
	return lpad n.toString(), len, '0'

# ---------------------------------------------------------------------------
# GENERATOR

export allMatches := (
		str: string,
		re: RegExp
		): Generator<string[], void, void> ->

	# --- Ensure the regex has the global flag (g) set
	newre := new RegExp(re, re.flags + (if re.flags.includes('g') then '' else 'g'))
	let lMatches: string[] | null = null
	while defined(lMatches = newre.exec(str))
		yield lMatches
	return

# ---------------------------------------------------------------------------

export range := (n: number): Generator<number, void, void> ->

	for i of [0...n]
		yield i
	return

# ---------------------------------------------------------------------------

export assertSameStr := (str1: string, str2: string): void =>
	if str1 != str2
		console.log sep '-', "Strings Differ:"
		console.log sep '-', "string 1"
		console.log str1
		console.log sep '-', "string 2"
		console.log str2
		console.log '-'.repeat 64
	assert (str1 == str2), "strings differ"
	return

# ---------------------------------------------------------------------------

export interpolate := (
		str: string,
		hReplace: hashof<string> # --- { <tag>: <replacement>, ... }
		): string =>

	for key of keys(hReplace)
		assert (key[0] == '$'), "all keys must start with '$'"
	re := /\$(?:[A-Za-z][A-Za-z0-9]*)/g
	return str.replaceAll re, (match: string) =>
		return hReplace[match] || match

# ---------------------------------------------------------------------------
# --- generate random labels

labelGen := (): Generator<string, void, void> ->

	for i of [65..90]
		ch := String.fromCharCode i
		yield ch
	for i of [65..90]
		ch := String.fromCharCode i
		for j of [65..90]
			ch2 := String.fromCharCode j
			yield ch + ch2
	for i of [65..90]
		ch := String.fromCharCode i
		for j of [65..90]
			ch2 := String.fromCharCode j
			for k of [65..90]
				ch3 := String.fromCharCode k
				yield ch + ch2 + ch3
	return

# ---------------------------------------------------------------------------
# --- Create an iterator from the generator

labels := labelGen()
export randomLabel := (): string =>
	label := labels.next()
	return if label.done then 'ERR!' else label.value

# ---------------------------------------------------------------------------

export require := createRequire import.meta.url

# ---------------------------------------------------------------------------

export getLineAndColumn := (text: string, pos: number) =>
	# --- Get line number by counting number of \n chars
	#        before the current position
	#     Get column number by finding closest previous position
	#        of a \n and computing the difference
	shortStr := text.substring 0, pos
	return [
		countChars(shortStr, "\n") + 1
		pos - shortStr.lastIndexOf('\n')
	]

# ---------------------------------------------------------------------------

# later? allow passing in string[] ???
export widthOf := (block: string): number =>
	let width = 0
	for line of allLinesInBlock(block)
		if line.length > width
			width = line.length
	return width

# ---------------------------------------------------------------------------

export heightOf := (block: string): number =>
	return if (block == '') then 0 else block.split('\n').length

# ---------------------------------------------------------------------------

export blockify := (lStrings: string[], hOptions: hash = {}): string =>
	type opt = {
		sep: string
		endsep: string
		width: number
		}
	{sep, endsep, width} := getOptions<opt> hOptions, {
		sep: ' '
		endsep: ''
		width: 64
		}

	lLines: string[] := []
	lWords: string[] := []
	let lineLen = endsep.length
	for str of lStrings
		# --- If adding the string makes the line too long,
		#     output the line and clear the array of words
		if lineLen + str.length + sep.length > width
			lLines.push lWords.join sep
			lWords.length = 0
			lineLen = 0
		lWords.push str
		lineLen += str.length + sep.length
	if lWords.length > 0
		lLines.push lWords.join sep
	return lLines.join '\n'

# ---------------------------------------------------------------------------

export getOptions := <T extends hash>(hOptions: hash = {}, hDefaults: T): T =>
	return { ...hDefaults, ...hOptions }

# ---------------------------------------------------------------------------

defWidth := 64

export sep := (
		char: string = '-',
		label: string? = undef,
		width: number = defWidth
		): string =>

	assert (char.length == 1), "Not a char: #{char}"
	if defined(label)
		return centered label, char, width
	else
		return char.repeat width

# ---------------------------------------------------------------------------

export tabify := (str: string, nSpaces: number = 3): string =>
	return str.replaceAll /^(\x20+)/, (match, spaces) =>
		return '\t'.repeat Math.floor spaces.length / nSpaces

# ---------------------------------------------------------------------------

export untabify := (str: string, replacement: string = '   '): string =>
	return str.replaceAll '\t', replacement

# ---------------------------------------------------------------------------

export allLinesInBlock := (
		block: string
		): Generator<string, void, void> ->

	let start = 0
	let end = block.indexOf '\n'
	while end != -1
		yield block.substring(start, end).replaceAll('\r', '')
		start = end + 1
		end = block.indexOf('\n', start)
	if start < block.length
		yield block.substring(start).replaceAll('\r', '')
	return

# ---------------------------------------------------------------------------

# --- valid options:
#        char - char to use on left and right
#        buffer - num spaces around label when char <> ' '
export centered := (label: string, char: string = ' ', width: number = defWidth, numBuffer: number = 2): string =>
	assert (char.length == 1), "Bad char: '#{char}'"
	totSpaces := width - label.length
	if totSpaces <= 0
		return label
	numLeft := Math.floor totSpaces / 2
	numRight := totSpaces - numLeft
	if char == ' '
		return ' '.repeat(numLeft) + label + ' '.repeat(numRight)
	else
		buf := ' '.repeat numBuffer
		left := char.repeat numLeft - numBuffer
		right := char.repeat numRight - numBuffer
		return left + buf + label + buf + right

# ---------------------------------------------------------------------------

export type TPredicate<T> = (item: T) => boolean

export splitArray := <T>(lItems: T[], predicate: TPredicate<T>): [T[], T[]] =>
	lTrue: T[] := []
	lFalse: T[] := []
	for item of lItems
		if predicate(item)
			lTrue.push item
		else
			lFalse.push item
	return [lTrue, lFalse]

# ---------------------------------------------------------------------------

export class CStringSetMap<T = string> < Map<T, Set<string>>
	# ..........................................................

	add(key: T, value: string): void
		aSet := super.get key
		if defined(aSet)
			aSet.add value
		else
			newSet := new Set<string>()
			newSet.add value
			super.set key, newSet
		return

	# ..........................................................

	hasKey(key: T): boolean
		return @has key

	# ..........................................................

	hasValue(val: string): boolean
		for key of @allKeys()
			set := @get key
			if defined(set) && set.has(val)
				return true
		return false

	# ..........................................................

	*allKeys(): Generator<T, void, void>
		yield *super.keys()
		return

	# ..........................................................

	*allValues(key: T): Generator<string, void, void>
		aSet := super.get key
		if defined(aSet)
			yield *aSet.values()
		return

	# ..........................................................

	asString(): string
		results1 := []
		for key of @allKeys()
			results1.push "#{key}: #{Array.from(@allValues key).join(' ')}"
		lLines := results1
		return lLines.join '\n'

# ---------------------------------------------------------------------------

export isTAML := (x: unknown): boolean =>

	if isString(x)
		try
			parseYAML(untabify(x))
			return true
		catch err
			return false
	else
		return false

# ---------------------------------------------------------------------------

export fromTAML := (block: string): unknown =>

	return parseYAML(untabify(block))
