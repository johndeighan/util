# from-nice.lib.civet

import {
	undef, defined, notdefined, assert, croak, hash, hashof,
	isArray, isFunction, isBoolean, isString, isNonPrimitive,
	isClass, isArrayOfStrings, isEmpty, nonEmpty, className,
	functionName, symbolName, classDef, functionDef, regexpDef,
	} from 'datatypes'
import {uni, delit} from 'unicode'
import {Fetcher} from 'fetcher'
import {getOptions, keys, toBlock, o, rtrim} from 'llutils'
import {toNice, OL} from 'to-nice'
import {
	TPLLToken, tkIndent, tkUndent, tkEOF, TTokenGenerator, allTokensInBlock,
	} from 'pll'

# ---------------------------------------------------------------------------

export niceSplitter := (
		str: string
		): Generator<TPLLToken, void, void> ->

	if (str.startsWith(uni.lsmartq))
		yield {
			kind: 'primitive'
			str
			value: str.substring(1)
			}
	else if (lMatches := str.match(/^-(.*)$/))
		tail := lMatches[1].trim()
		if tail
			yield {
				kind: 'list-item'
				str
				value: getPrimitive(tail)
			}
		else
			yield
				kind: 'list-head'
				name: str
				str: ''
	else if (lMatches := str.match(/^([A-Za-z][A-Za-z0-9_]*):(.*)$/))
		name := lMatches[1]
		tail := lMatches[2].trim()
		if tail
			yield {
				kind: 'hash-item'
				str
				name
				value: getPrimitive(tail)
			}
		else
			yield {
				kind: 'hash-head'
				name
				str
			}
	else
		yield {
			kind: 'primitive'
			str
			value: getPrimitive(str.trim())
		}

# ---------------------------------------------------------------------------

export allNiceTokens := (
		block: string
		): Generator<TPLLToken, void, void> ->

	for h of allTokensInBlock(block, niceSplitter)
		yield h
	return

# ---------------------------------------------------------------------------
# --- Create a Fetcher, then use
#     recursive descent parsing

export fromNice := (str: string): unknown =>

	fetcher := new Fetcher<TPLLToken>(allNiceTokens(str), tkEOF)

	parseObj := (): unknown =>
		{kind, str} := fetcher.peek()
		if kind == 'list-item' || kind == 'list-head'
			return parseList()
		else if kind == 'hash-item' || kind == 'hash-head'
			return parseHash()
		else if kind == 'eof'
			return undef
		else
			fetcher.skip()
			if defined(str)
				return getPrimitive str.trim()

	parseList := (): unknown[] =>
		lItems: unknown[] := []
		let {kind} = fetcher.peek()
		while ['list-item', 'list-head'].includes(kind)
			if kind == 'list-head'
				lItems.push parseListNest()
			else
				lItems.push fetcher.get().value
			kind = fetcher.peek().kind
		return lItems

	parseListNest := (): unknown[] =>
		fetcher.get kind: 'list-head', str: ''
		fetcher.get kind: 'indent', str: ''
		value := parseObj()
		fetcher.get kind: 'undent', str: ''
		return [value]

	parseHash := (): hash =>
		hItems: hash := {}
		let {kind, name} = fetcher.peek()
		if kind == 'hash-head'
			fetcher.skip()
			fetcher.get kind: 'indent', str: ''
			value := parseObj()
			if defined(name)
				hItems[name] = value
			fetcher.get kind: 'undent', str: ''
		else
			while kind == 'hash-item'
				{name, value} := fetcher.get()
				if defined(name)
					hItems[name] = value
				;({ kind } = fetcher.peek())
		return hItems

	return parseObj()

# ---------------------------------------------------------------------------
# --- str should already be trimmed

export getPrimitive := (str: string): unknown =>

	s := delit(str)   # delit() returns a trimmed string
	switch s
		when 'undef'  then return undef
		when 'null'   then return null
		when 'true'   then return true
		when 'false'  then return false
		when 'NaN'    then return NaN
		when 'inf'    then return Infinity
		when 'neginf' then return -Infinity
		when 'symbol' then return Symbol()
		when '[]'     then return []
		when '{}'     then return {}
		when undef
			if str.match(/^\d+$/)
				return parseInt str, 10
			else if str.match(/^\d+\.\d*$/)
				return parseFloat str
			else
				return str
		else
			# --- Handle a few special cases, e.g.
			#        ｟symbol <name>｠
			#        ｟regexp <pattern>｠
			assert defined(s), "Can't happen: s = #{OL(s)}"
			lMatches := s.match ///^
				(symbol | regexp)
				\s+
				(.*)
				$///
			if defined(lMatches)
				[_, kind, name] := lMatches
				switch kind
					when 'symbol'
						return Symbol(name)
					when 'regexp'
						return new RegExp(name)
			else
				croak "Bad primitive: #{str}"
