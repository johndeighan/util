# exec.lib.civet

import {exists, existsSync} from '@std/fs'
import {statSync} from 'node-fs'
import {stripAnsiCode} from '@std/fmt/colors'
import {
	CompilerOptions, ScriptTarget, ModuleKind, CompilerHost,
	createSourceFile, createProgram, getPreEmitDiagnostics,
	flattenDiagnosticMessageText, createCompilerHost,
	} from 'npm-typescript'
import {sprintf} from '@std/fmt/printf'

import {
	undef, defined, notdefined, assert, croak, hash, getErrStr,
	isString, isArray, isArrayOfStrings, isEmpty, nonEmpty,
	} from 'datatypes'
import {
	getOptions, pass, blockToArray, decode, encode, sep, centered,
	} from 'llutils'
import {write, writeln, resetLine } from 'console-utils'
import {flag, debugging, inspecting} from 'cmd-args'
import {OL, ML, DUMP} from 'to-nice'
import {
	curLogLevel, pushLogLevel, popLogLevel,
	DBG, LOG, DBGVALUE, LOGVALUE,
	INDENT, UNDENT,
	} from 'logger'
import {
	barf, pathStr, allFilesMatching, normalizePath, barfTempFile,
	fileExt, withExt, slurpAsync, parsePath, relpath,
	} from 'fsys'
import {syncReducer, asyncRunner} from 'var-free'

# ---------------------------------------------------------------------------

export mkstr := (
		item: (string | BufferSource)?
		): string =>

	if isString(item)
		return stripAnsiCode item
	else if isArray(item)
		return stripAnsiCode item.join ''
	else if defined(item)
		return stripAnsiCode decode item
	else
		return ''

# ---------------------------------------------------------------------------

export joinNonEmpty := (...lStrings: string?[]): string =>

	return lStrings.filter((s) => nonEmpty(s)).join('\n')

# ---------------------------------------------------------------------------

export getCmdLine := (cmdName: string, lArgs: string[]): string =>

	assert isString(cmdName), "cmdName not a string: #{OL(cmdName)}"
	assert isArrayOfStrings(lArgs), "not an array of strings: #{OL(lArgs)}"
	cmdLine := "#{cmdName} #{lArgs.join(' ')}"
	DBG "cmdLine = #{OL(cmdLine)}"
	return cmdLine

# ---------------------------------------------------------------------------

export type TStreamType = 'piped' | 'inherit'

export type TExecResult =
	success: boolean
	notNeeded?: true
	stdout?: string
	stderr?: string
	output?: string
	infile?: string
	outfile?: string
	debug?: string

export execCmdSync := (
		cmdName: string,
		lArgs: string[] = [],
		hOptions: hash = {}
		): TExecResult =>

	type opt = {
		capture: boolean
		}
	{capture} := getOptions<opt> hOptions, {
		capture: true
		}

	streamType: TStreamType := capture ? 'piped' : 'inherit'
	DBGVALUE "EXEC SYNC", "#{OL(getCmdLine cmdName, lArgs)}"
	DBG INDENT
	child := new Deno.Command cmdName,
		args: lArgs
		env: DEFAULT_LOGGER: curLogLevel()
		stdout: streamType
		stderr: streamType
	{
		success,
		stdout: rawStdOut
		stderr: rawStdErr
		} := child.outputSync()
	stdout := (capture && rawStdOut) ? decode(rawStdOut) : undef
	stderr := (capture && rawStdErr) ? decode(rawStdErr) : undef
	output := joinDefined stdout, stderr
	DBG UNDENT
	return {
		success,
		stdout,
		stderr,
		output,
		}

# ---------------------------------------------------------------------------

export type TReplaceHash =
	[key: string]: string

# ---------------------------------------------------------------------------
# ASYNC

type TFileProcessor = (input: string) => string

export execCmd := (
		cmdName: string
		lArgs: string[] = []
		hOptions: hash = {}
		): TExecResult =>

	type opt = {
		capture: boolean
		infile: string?
		inProc: TFileProcessor
		outfile: string?
		outProc: TFileProcessor
		}

	{
			capture, infile, inProc, outfile, outProc,
			} := getOptions<opt> hOptions, {
		capture: true
		infile: undef
		inProc: (str) => return str
		outfile: undef
		outProc: (str) => return str
		}

	streamType: TStreamType := capture ? 'piped' : 'inherit'
	if defined(infile) || defined(outfile)
		assert (streamType == 'piped'),
			"When specifying infile or outfile, capture must be true"
	try
		cmd := new Deno.Command cmdName, {
			args: lArgs
			env: DEFAULT_LOGGER: if debugging then 'debug' else 'info'
			stdin: streamType
			stdout: streamType
			stderr: streamType
			}
		child := cmd.spawn()
		if defined(infile)
			text := inProc Deno.readTextFileSync(infile)
			# --- Write the data to the stdin of the child process
			writer := child.stdin.getWriter()
			await writer.write encode(text)
			await writer.close()

		h := await child.output()
		{success} := h
		stdout := defined(h.stdout) ? outProc(decode h.stdout) : undef
		stderr := defined(h.stderr) ? outProc(decode h.stderr) : undef
		output := joinDefined(stdout, stderr) || ''
		if not success || not capture
			return {success, stdout, stderr, output}
		if defined(outfile)
			Deno.writeTextFileSync outfile, output
		return {
			success
			stdout
			stderr
			output
			outfile
			}
	catch err
		if debugging
			console.error err
		return {
			success: false
			stdout: undef
			stderr: getErrStr(err)
			output: getErrStr(err)
			}

# ---------------------------------------------------------------------------

type TStringGen = string | Uint8Array<ArrayBuffer>
type TStringSrc = undefined | TStringGen | TStringGen?[]

export joinDefined := (...lParts: TStringSrc[]): string? =>

	lStrings: string[] := []
	for src of lParts
		if (typeof src == 'string')
			lStrings.push decode src
		else if Array.isArray(src)
			for str of src
				if not defined(str)
					continue
				lStrings.push decode str
	return if (lStrings.length == 0) then undef else lStrings.join('\n')

# ---------------------------------------------------------------------------

export class CTimer

	t0 = Date.now()

	timeTaken(
			reset: boolean = true,
			decPlaces: number = 2
			): string

		now := Date.now()
		secs := (now - @t0) / 1000
		if reset
			@t0 = now
		return sprintf("%.#{decPlaces}d", secs)

timer := new CTimer()

# ---------------------------------------------------------------------------

export type THandlerResult = TExecResult & (path: string)

export abstract class CFileHandler

	abstract get op(): string

	abstract handle(
			path: string,
			hOptions: hash
			): Promise<THandlerResult>

# ---------------------------------------------------------------------------
# ASYNC

# --- Later, I want to allow passing multiple TProcSpecs
#     string is a glob pattern
export type TProcSpec = [CFileHandler, lPatterns: string[]]

export procFiles := (
		procSpec: TProcSpec,
		hOptions: hash = {}
		): TExecResult[] =>

	[handler, lPatterns] := procSpec
	{op} := handler
	if flag('v')
		writeln "(#{op})"

	lPaths: string[] := Array.from allFilesMatching(lPatterns)
	lPromises := for path of lPaths
		handler.handle path, hOptions

	[
		lFulfilled,
		lRejected,
		lFulPaths,
		lRejPaths
		] := await asyncRunner(lPromises, lPaths)

	nRej := lRejected.length
	[nNotNeeded, nOk, nErr] := syncReducer lFulfilled, [0,0,0], (acc, h) ->
		[n1, n2, n3] := acc
		if h.success
			if h.notNeeded
				return [n1+1, n2, n3]
			else
				return [n1, n2+1, n3]
		else
			return [n1, n2, n3+1]

	# --- Write results to the console

	for hResult of lFulfilled
		{path, success} := hResult
		if success
			if flag('v')
				showOkResult op, path, hResult
		else
			showErrResult op, path, hResult

	for reason,i of lRejected
		showRejResult op, lRejPaths[i], getErrStr(reason)

	showFinalResult op, nNotNeeded, nOk, nErr, nRej, lPatterns
	return lFulfilled

# ---------------------------------------------------------------------------

let headerPrinted = false

showFinalResult := (
		op: string,
		non: number,
		nOk: number,
		nErr: number,
		nRej: number,
		lPatterns: string[]
		): void =>

	resetLine()
	if flag('v')
		return
	if not headerPrinted
		LOG '-'.repeat 46
		LOG [
			sprintf('%6s', 'secs.')
			sprintf('%-14s', 'op')
			sprintf('%3s', 'non')
			sprintf('%3s', 'OK')
			sprintf('%3s', 'Bad')
			sprintf('%3s', 'Rej')
			'file(s)'
		].join ' '
		LOG '-'.repeat 46
		headerPrinted = true
	LOG [
		sprintf('%6.2f', timer.timeTaken())
		sprintf('%-14s', op)
		sprintf('%3d', non)
		sprintf('%3d', nOk)
		sprintf('%3d', nErr)
		sprintf('%3d', nRej)
		lPatterns.join(' + ')
	].join ' '
	return

# ---------------------------------------------------------------------------
# ASYNC

export procOneFile := (
		path: string,
		handler: CFileHandler,
		hOptions: hash = {}
		): THandlerResult =>

	assert existsSync(path), "No such file: #{path}"
	type opt = {
		capture: boolean
		dumpStdOut: boolean
		abortOnError: boolean
		inspect: boolean
		}
	{
		capture, dumpStdOut, abortOnError, inspect
		} := getOptions<opt> hOptions, {
			capture: true
			dumpStdOut: false
			abortOnError: true
			inspect: false
			}

	if inspect
		LOG "procOneFile(): inspect is set"

	# --- NOTE: if capture is false, we need to expect
	#           that when the handler is called,
	#           output will be produced

	op := handler.op
	if capture
		write "#{op} #{relpath(path)}"
	else
		writeln "#{op} #{relpath(path)} (no capture)"

	try
		hResult := await handler.handle path, hOptions
		{success, notNeeded} := hResult

		# --- If capture is false, output has already happened
		if capture
			if success
				writeln notNeeded ? " Not Needed" : " OK"
				if dumpStdOut
					showOkResult op, path, hResult
			else
				writeln " FAILED"
				showErrResult op, path, hResult
				if abortOnError
					Deno.exit 99
		hResult.path = path
		return hResult

	catch err
		if capture
			showRejResult op, path, err
		if abortOnError
			Deno.exit 99
		return {success: false, path}

# ---------------------------------------------------------------------------

showOkResult := (
		op: string
		path: string
		hResult: TExecResult
		): void =>

	if hResult.notNeeded
		LOG "NOT NEEDED"
	if nonEmpty(hResult.stdout)
		DUMP hResult.stdout, 'STDOUT'
	return

# ---------------------------------------------------------------------------

showErrResult := (
		op: string
		path: string
		hResult: TExecResult
		): void =>

	if nonEmpty(hResult.output)
		DUMP hResult.output, 'OUTPUT'
	return

# ---------------------------------------------------------------------------

showRejResult := (
		op: string
		path: string
		reason: unknown
		): void =>

	DUMP reason, 'ERROR'
	return

# ---------------------------------------------------------------------------
#       FileHandlers
# ---------------------------------------------------------------------------

class CFileRemover extends CFileHandler

	get op()
		return 'doRemoveFile'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		if existsSync(path)
			await Deno.remove path
		return {path, success: true}

export doRemoveFile := new CFileRemover()

# ---------------------------------------------------------------------------

class CFileEchoer extends CFileHandler

	get op()
		return 'doEchoFile'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		LOG await exists(path) ? "#{path}" : "#{path} - #{'does not exist'}:{red}"
		return {path, success: true}

export doEchoFile := new CFileEchoer()

# ---------------------------------------------------------------------------

class CTsFileRemover extends CFileHandler

	get op()
		return 'doRemoveTsFile'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		assert (fileExt(path) == '.ts'), "Not a TypeScript file: #{path}"
		civetPath := withExt path, '.civet'
		if await exists(civetPath)
			await Deno.remove path
			return {path, success: true}
		else
			return {path, success: true, notNeeded: true}

export doRemoveTsFile := new CTsFileRemover()

# ---------------------------------------------------------------------------

class CUnitTester extends CFileHandler

	get op()
		return 'doUnitTest'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		assert path.endsWith('.test.ts'), "Not a unit test file"
		type opt = {
			capture: boolean
			inspect: boolean
			}
		{capture, inspect} := getOptions<opt> hOptions, {
			capture: true
			inspect: false
			}

		hResult := (
			if inspect
				LOG "doUnitTest.handle(): inspect is set"
				await execCmd 'deno', [
					'test'
					'-A'
					'--inspect-brk'
					'--coverage-raw-data-only'
					path
					], {capture}
			else
				await execCmd 'deno', [
					'test'
					'-A'
					'--coverage-raw-data-only'
					path
					], {capture}
			)
		return {...hResult, path}

export doUnitTest := new CUnitTester()

# ---------------------------------------------------------------------------

class CCmdInstaller extends CFileHandler

	get op()
		return 'doInstallCmd'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		assert (fileExt(path) == '.ts'), "Not a TypeScript file: #{path}"
		name := parsePath(path).stub.replaceAll '.', '_'
		hResult := await execCmd 'deno', [
			'install'
			'--global'
			'--force'
			'--config', 'deno.json'
			'-A'
			'--name', name
			path
			]
		return {...hResult, path}

export doInstallCmd := new CCmdInstaller()

# ---------------------------------------------------------------------------

class CCmdUninstaller extends CFileHandler

	get op()
		return 'doUninstallCmd'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		name := parsePath(path).stub.replaceAll '.', '_'
		hResult := await execCmd 'deno', [
			'uninstall'
			'-gA'
			name
			path
			]
		return {...hResult, path}

export doUninstallCmd := new CCmdUninstaller()

# ---------------------------------------------------------------------------

class CFileRunner extends CFileHandler

	get op()
		return 'doRun'

	override handle(
			path: string,
			hOptions: hash = {}
			): THandlerResult

		assert (fileExt(path) == '.ts'), "Not a TypeScript file"

		hResult := if hOptions.inspect
			await execCmd 'deno', [
				'run'
				'-A'
				'--inspect-brk'
				path
				], hOptions
		else
			await execCmd 'deno', [
				'run'
				'-A'
				path
				], hOptions
		return {...hResult, path}

export doRun := new CFileRunner()
