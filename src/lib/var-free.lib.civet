# var-free.lib.civet

import {
	undef, defined, notdefined, getErrStr,
	isIterator, isAsyncIterator, isPromise, assertIsDefined,
	} from 'datatypes'

export type TMaybeCmd = 'stop' | undefined | void

# ---------------------------------------------------------------------------
# ASYNC

export function mapper<TIn, TOut>(
		lItems:  Generator<TIn> |
					AsyncGenerator<TIn> |
					TIn[]
		mapFunc: (x: TIn, i: number) =>
			TOut? |
			Promise<TOut?> |
			Generator<TOut, TMaybeCmd> |
			AsyncGenerator<TOut, TMaybeCmd>
		): AsyncGenerator<TOut>

	# --- NOTE: You can await something even if it's not async
	for await item,i of lItems
		iter := mapFunc item, i
		if isIterator(iter)
			loop
				{done, value} := iter.next()
				if done
					if (value == 'stop')  # value returned from mapFunc()
						return
					else
						break
				else if (value != undefined)
					yield value
		else if isAsyncIterator(iter)
			loop
				{done, value} := await iter.next()
				if done
					if (value == 'stop')  # value returned from mapFunc()
						return
					else
						break
				else if (value != undefined)
					yield value
		else if (iter != undefined)
			if isPromise(iter)
				# --- iter is a TOut
				result := await iter
				if (result != undefined)
					yield result
			else
				yield iter
	return

# ---------------------------------------------------------------------------
# ASYNC

export reducer := <TIn, TAccum>(
		lItems: Generator<TIn> |
				AsyncGenerator<TIn> |
				TIn[]
		acc: TAccum
		redFunc: (acc: TAccum, x: TIn, i: number) =>
			TAccum? |
			Promise<TAccum?> |
			Generator<TAccum, TMaybeCmd> |
			AsyncGenerator<TAccum, TMaybeCmd>
		): TAccum ->

	for await item,i of lItems
		iter := redFunc acc, item, i
		if isIterator(iter) || isAsyncIterator(iter)
			loop
				{done, value} := await iter.next()
				if done
					if (value == 'stop')
						return await acc
					else
						break
				else if (value != undefined)
					acc = value
		else if (iter != undefined)
			if isPromise(iter)
				result := await iter
				if (result != undefined)
					acc = result
			else
				acc = iter
	return await acc

# ---------------------------------------------------------------------------

export function syncMapper<TIn, TOut>(
		lItems:  IterableIterator<TIn> | TIn[]
		mapFunc: (x: TIn, i: number) =>
			TOut? |
			Generator<TOut, TMaybeCmd>
		): Generator<TOut, TMaybeCmd>

	for item,i of lItems
		iter := mapFunc item, i
		if isIterator(iter) || isAsyncIterator(iter)
			assertIsDefined(iter)
			loop
				# --- I'm tired of wrestling with TypeScript !
				# @ts-ignore
				{done, value} := iter.next()
				if done
					if (value == 'stop')
						return
					else
						break
				else if (value != undefined)
					yield value
		else if defined(iter)
			yield iter
	return

# ---------------------------------------------------------------------------

export syncReducer := <TIn, TAccum>(
		lItems: Generator<TIn> | TIn[]
		acc: TAccum
		redFunc: (acc: TAccum, x: TIn, i: number) =>
			TAccum? |
			Generator<TAccum, TMaybeCmd>
		): TAccum ->

	for item,i of lItems
		iter := redFunc acc, item, i
		if (iter != undefined)
			if isIterator(iter)
				loop
					{done, value} := iter.next()
					if done
						if (value == 'stop')
							return acc
						else
							break
					else if (value != undefined)
						acc = value
			else
				# --- now iter is of type TAccum
				acc = iter
	return acc

# ---------------------------------------------------------------------------
# ASYNC
# --- returns [lFulfilled, lRejected, lFulfilledTags, lRejectedTags]
#        lFulfilled is an array of T
#        lRejected is an array of unknown (usually Error objects)
#        lFulfilledTags and lRejectedTags are arrays of strings

type TResult<T> = [T[], unknown[], string[], string[]]

export asyncRunner := <T>(
		lPromises: Promise<T>[]
		lTags: string[] = []
		): TResult<T> ->

	lSettled := await Promise.allSettled(lPromises)
	acc0: TResult<T> := [[],[],[],[]]
	return await reducer lSettled, acc0, (acc, h, i): TResult<T> ->
		tag := (i >= 0) && (i < lTags.length) ? lTags[i] : ''
		[lFulfilled, lRejected, lTags1, lTags2] := acc
		if (h.status == 'fulfilled')
			return [
				[...lFulfilled, h.value],
				lRejected,
				[...lTags1, tag],
				lTags2
				]
		else
			return [
				lFulfilled
				[...lRejected, getErrStr(h.reason)]
				lTags1
				[...lTags2, tag]
				]
