# var-free.lib.civet

export type TMaybeString = string | undefined | void
export type TIterator<T, U> = Generator<T, U>
export type TAsyncIterator<T, U> = AsyncGenerator<T, U>

export type TMapper<TIn, TOut>      = (item: TIn, i: number) => TIterator<TOut, TMaybeString>
export type TAsyncMapper<TIn, TOut> = (item: TIn, i: number) => TAsyncIterator<TOut, TMaybeString>

# ---------------------------------------------------------------------------

export function syncMapper<TIn, TOut>(
		lItems:  Iterable<TIn>
		mapFunc: (item: TIn, i: number) => TIterator<TOut, TMaybeString>
		): Generator<TOut, TMaybeString>

	for item,i of lItems
		iter := mapFunc item, i
		loop
			{done, value} := iter.next()
			if done
				if (value == 'stop')
					return
				else
					break
			else
				yield value
	return

# ---------------------------------------------------------------------------

export syncReducer := <TIn, TAccum>(
		lItems: Iterable<TIn>
		acc: TAccum
		reduceFunc: (acc: TAccum, x: TIn, i: number) => TIterator<TAccum, TMaybeString>
		): TAccum ->

	for item,i of lItems
		iter := reduceFunc acc, item, i
		loop
			{done, value} := iter.next()
			if done
				if (value == 'stop')
					return acc
				else
					break
			else
				acc = value
	return acc

# ---------------------------------------------------------------------------

export function mapper<TIn, TOut>(
		lItems:     Iterable<TIn>
		mapFunc:    (item: TIn, i: number) => TIterator<TOut, TMaybeString>
		): AsyncGenerator<TOut, TMaybeString>

export function mapper<TIn, TOut>(
		lItems:     AsyncIterable<TIn>
		mapFunc:    (item: TIn, i: number) => (TIterator<TOut, TMaybeString> | TAsyncIterator<TOut, TMaybeString>)
		): AsyncGenerator<TOut, TMaybeString>

export function* mapper<TIn, TOut>(
		lItems:    Iterable<TIn>      | AsyncIterable<TIn>
		mapFunc:   (item: TIn, i: number) => (TIterator<TOut, TMaybeString> | TAsyncIterator<TOut, TMaybeString>)
		): AsyncGenerator<TOut, TMaybeString>

	# --- NOTE: You can await something even if it's not async
	for await item,i of lItems
		iter := mapFunc item, i
		loop
			{done, value} := await iter.next()
			if done
				if (value == 'stop')
					return
				else
					break
			else
				yield value
	return

# ---------------------------------------------------------------------------

export reducer := <TIn, TAccum>(
		lItems: Iterable<TIn> | AsyncIterable<TIn>
		acc: TAccum
		reduceFunc: (acc: TAccum, item: TIn, i: number) => TIterator<TAccum, TMaybeString>
		): TAccum ->

	for await item,i of lItems
		iter := reduceFunc acc, item, i
		loop
			{done, value} := iter.next()
			if done
				if (value == 'stop')
					return await acc
				else
					break
			else
				acc = value
	return await acc
