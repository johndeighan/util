# f-strings.lib.civet

import {sprintf} from 'jsr:@std/fmt/printf'

import {esc} from 'unicode'
import {defined, nonEmpty, isInteger} from 'datatypes'

# ---------------------------------------------------------------------------
# --- Number of strings is always 1 greater than the number of values

export f := (
		lStrings: TemplateStringsArray
		...lValues: unknown[]
		): string =>

	lParts: string[] := [lStrings[0]]
	for val,i of lValues
		[nextStr, width, escape] := fsplit lStrings[i+1]
		lParts.push (
			switch typeof val
				when 'string'
					valStr := escape ? esc(val) : val
					width ? sprintf("%-#{width}s", valStr) : valStr
				when 'number'
					if (width == 0)
						val.toString()
					else if isInteger(val)
						sprintf("%#{width}d", val)
					else
						sprintf("%#{width}.2f", val)
				else
					valStr := JSON.stringify(val)
					width ? sprintf("%-s#{width}", valStr) : valStr
			)
		lParts.push nextStr
	return lParts.join('')

# ---------------------------------------------------------------------------
# --- returns [str, width, escape?]

export fsplit := (str: string): [string, number, boolean] =>

	lMatches := str.match(/^:(\!)?(\d+)?(.*)$/)
	if defined(lMatches)
		[_, escape, width, rest] := lMatches
		return [
			rest
			width ? parseInt(width) : 0
			nonEmpty(escape)
			]
	else
		return [str, 0, false]
