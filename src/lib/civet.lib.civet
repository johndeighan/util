# civet.lib.civet

import {existsSync} from '@std/fs'
import {statSync} from 'node-fs'
import {Node, SourceFile} from 'npm-typescript'
import {compile: compileCivet} from '@danielx/civet'
import {RawSourceMap} from 'npm-source-map'

import {
	undef, defined, notdefined, hash, assert, isString, isHash,
	} from 'datatypes'
import {getOptions, o, getErrStr} from 'llutils'
import {OL, ML} from 'to-nice'
import {LOG, DBG, DBGVALUE} from 'logger'
import {flag, debugging, inspecting} from 'cmd-args'
import {
	isFile, fileExt, withExt, slurp, slurpAsync, pathStr,
	barf, barfTempFile, parsePath, addJsonValue, normalizePath,
	} from 'fsys'
import {
	TExecResult, execCmdSync, execCmd, CFileHandler,
	} from 'exec'
import {ts2ast, analyze} from 'typescript'
import {extractSourceMap, haveSourceMapFor} from 'source-map'

import hCivetConfig from "civetconfig" with { type: "json" };

# ---------------------------------------------------------------------------
# --- Due to a bug in either the v8 engine or Deno,
#     we have to generate, then remove the inline source map,
#     saving it to use in mapping source lines later

class CCivetCompiler extends CFileHandler

	get op()
		return 'doCompileCivet'

	override handle(
			path: string,
			hOptions: hash = {}
			): TExecResult

		assert (fileExt(path) == '.civet'), "Not a civet file: #{path}"
		destPath := withExt path, '.ts'

		# --- Check if a newer compiled version already exists
		if (
				   not hOptions.force
				&& existsSync(destPath)
				&& (statSync(destPath).mtimeMs > statSync(path).mtimeMs)
				&& haveSourceMapFor(path)
				)
			return {success: true}

		try
			civetCode := await slurpAsync path
			tsCode: string := await compileCivet civetCode, {
				...hCivetConfig
				inlineMap: true
				filename: path
				}
			if not tsCode || tsCode.startsWith('COMPILE FAILED')
				errMsg := "CIVET COMPILE FAILED: #{pathStr(path)}"
				return {
					success: false
					stderr: errMsg
					output: errMsg
					}
			tempPath := barfTempFile tsCode, {ext: '.ts'}
			hResult := await execCmd 'deno', ['check', tempPath]
			assert hResult.success, "Type check failed"
			[code, hSrcMap] := extractSourceMap(tsCode)
			if defined(hSrcMap)
				addJsonValue 'sourcemap.jsonc', normalizePath(destPath), hSrcMap
			await Deno.writeTextFile destPath, code
			return {success: true}
		catch err
			if debugging
				LOG getErrStr(err)
			errMsg := "COMPILE FAILED: #{pathStr(path)} - #{getErrStr(err)}"
			return
				success: false
				stderr: errMsg
				output: errMsg

export doCompileCivet := new CCivetCompiler()

# ---------------------------------------------------------------------------

export civet2tsFile := (
		path: string,
		tsPath: string = withExt(path, '.ts'),
		hOptions: hash = {}
		): string =>

	assert (fileExt(path) == '.civet'), "Not a civet file: #{OL(path)}"
	assert isFile(path), "No such file: #{OL(path)}"
	type opt = {
		nomap: boolean
		}
	{nomap} := getOptions<opt> hOptions, {
		nomap: false
		}

	execCmdSync 'deno', [
		'run'
		'-A'
		'npm:@danielx/civet'
		...if nomap then [] else ['--inline-map']
		'-o'
		tsPath
		'-c'
		path
	]
	assert isFile(tsPath), "File not created: #{OL(tsPath)}"
	return tsPath

# ---------------------------------------------------------------------------

export civet2ts := (
		civetCode: string,
		hOptions: hash = {}
		): string =>

	tempFilePath := barfTempFile civetCode
	tsFilePath := withExt tempFilePath, '.ts'
	civet2tsFile tempFilePath, tsFilePath, hOptions
	contents := slurp tsFilePath
	return contents

# ---------------------------------------------------------------------------

export civet2ast := (civetCode: string): Node =>

	tsCode := civet2ts civetCode
	return ts2ast tsCode

# ---------------------------------------------------------------------------

# --- template literals to simplify displaying
#     the analysis of civet code

export a := (lStrings: TemplateStringsArray): string =>
	return analyze(civet2ts lStrings[0]).asString()

export A := (lStrings: TemplateStringsArray): string =>
	return analyze(civet2ts(lStrings[0]), o'dump').asString()