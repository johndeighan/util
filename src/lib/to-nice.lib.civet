# to-nice.lib.civet

import {uni, esc} from 'unicode'
import {write, writeln} from 'console-utils'
import {
	assert, croak, undef, defined, notdefined,
	hash, hashof, isString, isArray, isClass, isRegExp, isObject,
	isPrimitive, isEmpty, nonEmpty, assertIsHash, integer,
	symbolName, className, functionName, regexpDef,
	} from 'datatypes'
import {
	getOptions, f, o, toBlock, spaces, mapEachLine, sep,
	} from 'llutils'

# ---------------------------------------------------------------------------

export mark := (str: string): string =>

	return uni.startchar + str + uni.endchar

# ---------------------------------------------------------------------------

export type TCompareFunc = (a: string, b: string) => number

export alphaCompare: TCompareFunc := (a: string, b: string): number =>

	return if (a < b) then -1 else if (a > b) then 1 else 0

# ---------------------------------------------------------------------------

# --- any leading digit must be preceded by a single '\'

export toNiceString := (
		str: string,
		compact: boolean = true
		): string =>

	# --- escape spaces and \t, \n or \r with unicode chars
	estr := esc(str, compact ? 'oneline' : 'multiline')

	# --- precede with '“' if
	#        - starts with digit
	#        - starts with '-'
	#        - looks like a label
	if estr.match(/^[\d-]/) || estr.match(/^\.\d/)
		return uni.lsmartq + estr
	else if estr.match(///^ [^˳\s]+ \: ˳///)
		return uni.lsmartq + estr
	else
		return estr

# ---------------------------------------------------------------------------

# --- Returns a function that:
#        compares 2 strings based on their position in lSortKeys
#        else compares alphabetically
getCompareFunc := (lSortKeys: string[]): TCompareFunc =>

	# --- Create map of key to number
	h: hashof<number> := {}
	let i1 = 0
	for key of lSortKeys
		i := i1++
		h[key] = i + 1
	return function(a: string, b: string): number
		aVal := h[a]
		bVal := h[b]
		if defined(aVal)
			if defined(bVal)
				# --- compare numerically
				return (aVal < bVal) ? -1 : (aVal > bVal) ? 1 : 0
			else
				return -1
		else
			if defined(bVal)
				return 1
			else
				return alphaCompare a, b

# ---------------------------------------------------------------------------

export rotpos := <T>(
	lArray: T[],
	i: integer
	): T =>

	return lArray[i % lArray.length]

# ---------------------------------------------------------------------------

indented := (block: string, oneIndent: string) =>

	return mapEachLine block, (line) => oneIndent + line

# ---------------------------------------------------------------------------

export type TPathIndex = string | number
export buildPath := (lPath: TPathIndex[]): string =>

	let str = 'root'
	for item of lPath
		if isString(item)
			str += ".#{item}"
		else
			str += "[#{item.toString()}]"
	return str

# ---------------------------------------------------------------------------

export displayStr := (
		key: string
		val: unknown
		par: hash
		displayFunc: TMapFunc?
		descFunc: TMapFunc?
		): string =>

	str := (
		  defined(displayFunc)
		? displayFunc(key, val, par)
		: toNice(val, {compact: true})
		)
	desc := defined(descFunc) ? descFunc(key, val, par) : ''
	return desc ? f"#{str} #{desc}:{cyan}" : str

# ---------------------------------------------------------------------------

export type TMapFunc = (
		key: string,
		value: unknown,
		hParent: hash
		) => string

export toNice := (
		x: unknown,
		hOptions: hash = {},
		mapVisited: Map<object, string> = new Map<object, string>(),
		lPath: TPathIndex[] = []
		): string =>

	# --- When recoverable, classes and functions
	#     include their definitions,
	#     with escaped chars
	type opt =
		compact: boolean
		recoverable: boolean
		ignoreEmptyValues: boolean
		sortKeys: boolean
		sortFunc: TCompareFunc?
		displayFunc: TMapFunc?
		descFunc: TMapFunc?
		lInclude: string[]?
		lExclude: string[]?
		lIndents: string[]
	{
			compact, recoverable, ignoreEmptyValues,
			sortKeys, sortFunc,
			displayFunc, descFunc, lInclude, lExclude, lIndents
			} := getOptions<opt> hOptions, {
		compact: false
		recoverable: false
		ignoreEmptyValues: false
		sortKeys: false
		sortFunc: undef
		displayFunc: undef
		descFunc: undef
		lInclude: undef
		lExclude: undef
		lIndents: ['   ', '❘  ']
		}

	if recoverable
		assert notdefined(displayFunc), "can't use displayFunc if recoverable"
		assert notdefined(descFunc), "can't use descFunc if recoverable"

	# --- You can provide sortKeys or a sortFunc, but not both
	assert not (sortKeys && defined(sortFunc)), "Bad options"
	switch typeof x
		case 'undefined':
			return mark('undef')
		case 'boolean':
			return if x then mark('true') else mark('false')
		case 'number':
			return (
				  Number.isNaN(x)    ? mark('NaN')
				: Number.isFinite(x) ? x.toString()
				:                      ((x < 0) ? mark('neginf') : mark('inf'))
				)
		case 'bigint':
			return x.toString() + 'n'
		case 'string':
			return toNiceString x, compact
		case 'symbol':
			name := symbolName x
			if name
				return mark("symbol #{name}")
			else
				return mark("symbol")
		case 'function':
			if isClass(x)
				name := className x
				if name
					return mark("class #{name}")
				else
					return mark("class")
			else
				name := functionName x
				if name
					return mark("function #{name}")
				else
					return mark("function")
		case 'object':
			if x == null
				return mark('null')

			# --- Check if object was previously visited
			prevpath := mapVisited.get x
			if prevpath
				return mark("ref #{prevpath}")
			if isRegExp(x)
				desc := esc regexpDef x
				if desc
					return mark("regexp #{desc}")
				else
					return mark("regexp")
			if isArray(x)
				if x.length == 0
					return '[]'
				mapVisited.set x, buildPath(lPath)
				lLines := []
				for val,i of x
					block := toNice val, hOptions, mapVisited, [...lPath, i]
					if compact
						lLines.push block
					else if isPrimitive(val) || block.startsWith('.') || isEmpty(val)
						lLines.push "- #{block}"
					else
						lLines.push '-'
						oneIndent := rotpos<string> lIndents, lPath.length
						lLines.push indented(block, oneIndent)
				if compact
					return '[' + lLines.join(' ') + ']'
				else
					return toBlock lLines

			# --- It's an object
			if (x instanceof Set)
				lParts := for key of x.keys()
					toNice key
				return (
					  (lParts.length == 0)
					? mark "emptySet"
					: mark "set #{lParts.join(' ')}"
					)
			if (x instanceof Map)
				lParts := for [key, val] of x.entries()
					keyStr := toNice(key)
					valStr := toNice(val, hOptions, mapVisited, [...lPath, key])
					if valStr.includes('\n')
						oneIndent := rotpos<string> lIndents, lPath.length
						indented valStr, oneIndent
					else
						"#{keyStr}:: #{valStr}"
				return (lParts.length == 0) ? mark('emptyMap') : lParts.join('\n')

			lKeys := Object.keys x
			if lKeys.length == 0
				return '{}'
			func: TCompareFunc? := (
				if defined(sortFunc)
					sortFunc
				else if defined(lInclude)
					getCompareFunc(lInclude)
				else if sortKeys
					alphaCompare
				else
					undef
				)
			useKey := (key: unknown): boolean =>
				if (typeof key != 'string')
					return false
				if defined(lExclude) && lExclude.includes(key)
					return false
				if defined(lInclude) && not lInclude.includes(key)
					return false
				return true
			mapVisited.set x, buildPath(lPath)
			assertIsHash x # --- will allow us to index with any string
			lLines := []
			for key of (defined(func) ? lKeys.sort(func) : lKeys).filter(useKey)
				val := x[key]
				if not ignoreEmptyValues || nonEmpty(val)
					if (val == null)
						lLines.push "#{key}: #{mark('null')}"
					else if isPrimitive(val)
						str := displayStr(key, val, x, displayFunc, descFunc)
						lLines.push "#{key}: #{str}"
					else
						prevpath := isObject(val) ? mapVisited.get val : undef
						if defined(prevpath)
							str := mark "ref #{prevpath}"
							lLines.push "#{key}: #{str}"
						else if isEmpty(val)
							str := (
								  (val instanceof Set) ? mark('emptySet')
								: (val instanceof Map) ? mark('emptyMap')
								: isArray(val)         ? '[]'
								:                        '{}'
								)
							lLines.push "#{key}: #{str}"
						else
							lLines.push "#{key}:"
							oneIndent := rotpos<string> lIndents, lPath.length
							block := toNice(val, hOptions, mapVisited, [...lPath, key])
							lLines.push indented(block, oneIndent)

			if compact
				return '{' + lLines.join(' ') + '}'
			else
				return toBlock lLines
	return "<Unknown object #{x}>"

# ---------------------------------------------------------------------------

export OL := (
		x: unknown,
		hOptions = {}
		): string =>

	type opt = {
		label: string?
		pos: number?
		debug: boolean
		}
	{label, pos, debug} := getOptions<opt> hOptions, {
		label: undef
		pos: undef
		debug: false
		}

	text := (
		if defined(label)
			"#{label} = #{toNice(x, {compact: true})}"
		else
			toNice(x, compact: true)
		)
	if debug
		n := Math.floor(text.length / 10) + 1
		return [
			text
			'\n'
			' '.repeat(if defined(label) then label.length + 3 else 0)
			"|         ".repeat(n)
		].join ''
	else
		return text

# ---------------------------------------------------------------------------

export ML := (x: unknown, hOptions = {}): string =>

	type opt =
		label: string?
	{label} := getOptions<opt> hOptions,
		label: undef
	if defined(label)
		return [
			sep('-', label)
			toNice(x, compact: false)
			sep('-')
		].join '\n'
	else
		return toNice x, compact: false

# ---------------------------------------------------------------------------

export DUMP := (
		x: unknown,
		label: string? = undef,
		hOptions: hash = {}
		): void =>

	type opt = {
		width: number
		char: string
		endLabel: boolean
		}
	{width, char, endLabel} := getOptions<opt> hOptions, {
		width: 64
		char: '-'
		endLabel: false
		}
	writeln sep(char, label, width)
	if isString(x)
		if nonEmpty(x)
			writeln x
	else
		writeln toNice(x, hOptions)
	writeln sep(char, (endLabel ? "END #{label}" : undef), width)
	return