# to-nice.lib.civet

import {uni, esc} from 'unicode'
import {write, writeln} from 'console-utils'
import {
	assert, croak, undef, defined, notdefined,
	hash, hashof, isString, isArray, isClass, isRegExp, isObject,
	isPrimitive, isEmpty, nonEmpty, assertIsHash, integer,
	symbolName, className, functionName, regexpDef, jsType,
	assertIsFunction, assertIsClass, assertIsArray,
	} from 'datatypes'
import {
	getOptions, f, o, toBlock, spaces, mapEachLine, sep, keys,
	} from 'llutils'
import {indented} from 'indent'
import {mapper, syncMapper} from 'var-free'

# ---------------------------------------------------------------------------

export mark := (str: string): string =>

	return uni.startchar + str + uni.endchar

# ---------------------------------------------------------------------------

export type TCompareFunc = (a: string, b: string) => number

export alphaCompare: TCompareFunc := (a: string, b: string): number =>

	return if (a < b) then -1 else if (a > b) then 1 else 0

# ---------------------------------------------------------------------------

# --- any leading digit must be preceded by a curly quote char

export toNiceString := (
		str: string,
		): string =>

	if (str == '')
		return mark('emptyString')

	# --- escape spaces and \t, \n or \r with unicode chars
	estr := esc(str)

	# --- precede with '“' if
	#        - starts with digit
	#        - starts with '-'
	#        - looks like a label
	if estr.match(/^[\d-]/) || estr.match(/^\.\d/)
		return uni.lsmartq + estr
	else if estr.match(///^ [^˳\s]+ \: ˳///)
		return uni.lsmartq + estr
	else
		return estr

# ---------------------------------------------------------------------------
# --- Returns a function that:
#        compares 2 strings based on their position in lSortKeys
#        else compares alphabetically

export getCompareFunc := (
		lSortKeys: string[]
		): TCompareFunc =>

	# --- Create map of key to number
	h: hashof<number> := {}
	let i1 = 0
	for key of lSortKeys
		i := i1++
		h[key] = i + 1
	return function(a: string, b: string): number
		aVal := h[a]
		bVal := h[b]
		if defined(aVal)
			if defined(bVal)
				# --- compare numerically
				return (aVal < bVal) ? -1 : (aVal > bVal) ? 1 : 0
			else
				return -1
		else
			if defined(bVal)
				return 1
			else
				return alphaCompare a, b

# ---------------------------------------------------------------------------

export rotpos := <T>(
	lArray: T[],
	i: integer
	): T =>

	return lArray[i % lArray.length]

# ---------------------------------------------------------------------------

export type TPathIndex = string | number
export buildPath := (lPath: TPathIndex[]): string =>

	let str = 'root'
	for item of lPath
		if isString(item)
			str += ".#{item}"
		else
			str += "[#{item.toString()}]"
	return str

# ---------------------------------------------------------------------------

export type TMapFunc = (
		key: string,
		value: unknown,
		hParent: unknown
		) => string

# ---------------------------------------------------------------------------

export type TNiceOptions = {
	compact: boolean
	recoverable: boolean
	oneIndent: string
	ignoreEmptyKeys: boolean
	ignoreEmptyItems: boolean
	sortKeys: boolean
	sortFunc: TCompareFunc?
	displayFunc: TMapFunc?
	descFunc: TMapFunc?
	lInclude: string[]?
	lExclude: string[]
	}

export hNiceDefaults := {
	compact: false
	recoverable: false
	oneIndent: '   '
	ignoreEmptyKeys: false
	ignoreEmptyItems: false
	sortKeys: false
	sortFunc: undef
	displayFunc: undef
	descFunc: undef
	lInclude: undef
	lExclude: []
	}

# ---------------------------------------------------------------------------

export hash2nice := (
		mark: string
		parent: unknown
		lKeys: string[]
		getter: (s: string) => unknown
		hOptions: hash = {}
		mapVisited: Map<object, string>
		lPath: TPathIndex[]
		): string =>

	{compact, sortFunc, sortKeys, lInclude, lExclude, ignoreEmptyKeys,
		displayFunc, descFunc, oneIndent, recoverable,
		} := getOptions<TNiceOptions> hOptions, hNiceDefaults

	# --- You can provide sortKeys or a sortFunc, but not both
	assert not (sortKeys && defined(sortFunc)), "Bad options"

	if recoverable
		assert notdefined(displayFunc), "can't use displayFunc w/recoverable"
		assert notdefined(descFunc), "can't use descFunc w/recoverable"

	func: TCompareFunc? := (
		if defined(sortFunc)
			sortFunc
		else if defined(lInclude)
			getCompareFunc(lInclude)
		else if sortKeys
			alphaCompare
		else
			undef
		)
	useKey := (key: string): boolean =>
		if lExclude.includes(key)
			return false
		if defined(lInclude) && not lInclude.includes(key)
			return false
		return true
	iterKeys := (defined(func) ? lKeys.sort(func) : lKeys).filter(useKey)
	iterParts := syncMapper iterKeys, (key: string): Generator<string> ->
		val := getter(key)
		if not ignoreEmptyKeys || nonEmpty(val)
			if isPrimitive(val)
				str := displayStr(key, val, parent, displayFunc, descFunc)
				yield "#{key}#{mark} #{str}"
			else
				str := toNice(val, hOptions, mapVisited, [lPath..., key])
				if str.includes('\n')
					yield "#{key}#{mark}\n" + indented(str, 1, {oneIndent})
				else
					yield "#{key}#{mark} #{str}"
	lParts := Array.from(iterParts)
	return (
		  compact
		? '{' + lParts.join(' ') + '}'
		: lParts.join('\n')
		)

# ---------------------------------------------------------------------------

export seq2nice := (
		prefix: string
		lValues: unknown[]
		hOptions: hash = {}
		mapVisited: Map<object, string>
		lPath: TPathIndex[]
		): string =>

	{compact, ignoreEmptyItems, oneIndent
		} := getOptions<TNiceOptions> hOptions, hNiceDefaults

	iterParts := syncMapper lValues, (val: unknown, i: number): Generator<string> ->
		if not ignoreEmptyItems || nonEmpty(val)
			str := toNice(val, hOptions, mapVisited, [lPath..., i])
			if str.includes('\n')
				yield "#{prefix}\n" + indented(str, 1, {oneIndent})
			else if compact
				yield str
			else
				yield "#{prefix} #{str}"
	lParts := Array.from(iterParts)
	return (
		  compact
		? '[' + lParts.join(' ') + ']'
		: lParts.join('\n')
		)

# ---------------------------------------------------------------------------

export toNice := (
	x: unknown
	hOptions: hash = {},
	mapVisited: Map<object, string> = new Map<object, string>(),
	lPath: TPathIndex[] = []
	): string =>

	{compact, recoverable, oneIndent, displayFunc, descFunc
		} := getOptions<TNiceOptions> hOptions, hNiceDefaults

	typ := jsType(x)
	switch typ
		when 'undef','NaN','inf','neginf','null'
			return mark(typ)
		when 'boolean'
			return x ? mark('true') : mark('false')
		when 'string'
			return toNiceString(x as string)
		when 'symbol'
			name := symbolName x
			return name ? mark("symbol #{name}") : mark("symbol")
		when 'bigint'
			return (x as bigint).toString() + 'n'
		when 'integer','float'
			return (x as number).toString()
		when 'regexp'
			desc := esc regexpDef x
			return desc ? mark("regexp /#{desc}/") : mark("regexp")
		when 'array'
			assertIsArray(x)
			if (x.length == 0)
				return '[]'
			else
				# --- Check if object was previously visited
				prevpath := mapVisited.get x
				if prevpath
					return mark("ref #{prevpath}")
				else
					mapVisited.set x, buildPath(lPath)
					return seq2nice '-', x, hOptions, mapVisited, lPath
		when 'set'
			assert (x instanceof Set)
			if (x.size == 0)
				return mark('emptySet')
			else
				# --- Check if object was previously visited
				prevpath := mapVisited.get x
				if prevpath
					return mark("ref #{prevpath}")
				else
					mapVisited.set x, buildPath(lPath)
					lValues := Array.from(x.values())
					return seq2nice '--', lValues, hOptions, mapVisited, lPath
		when 'hash'
			assertIsHash(x)
			lKeys := Object.keys(x)
			if (lKeys.length == 0)
				return '{}'
			else
				# --- Check if object was previously visited
				prevpath := mapVisited.get x
				if prevpath
					return mark("ref #{prevpath}")
				else
					mapVisited.set x, buildPath(lPath)
					getter := (name: string): unknown => x[name]
					return hash2nice ':', x, keys(x), getter, hOptions, mapVisited, lPath
		when 'map'
			assert (x instanceof Map)
			if (x.size == 0)
				return mark('emptyMap')
			else
				# --- Check if object was previously visited
				prevpath := mapVisited.get x
				if prevpath
					return mark("ref #{prevpath}")
				else
					mapVisited.set x, buildPath(lPath)
					getter := (name: string): unknown =>
						return x.get(name)
					lKeys := Array.from(x.keys())
					return hash2nice '::', x, lKeys, getter, hOptions, mapVisited, lPath
		when 'generator'
			assertIsFunction(x)
			return mark("generator #{functionName(x)}")
		when 'asyncGenerator'
			assertIsFunction(x)
			return mark("asyncGenerator #{functionName(x)}")
		when 'class'
			assertIsClass(x)
			return mark("class #{className(x)}")
		when 'plainFunction'
			assertIsFunction(x)
			return mark("function #{functionName(x)}")

	return mark('unknown')

# ---------------------------------------------------------------------------
# --- val must be a primitive

export displayStr := (
		key: string
		val: unknown
		parent: unknown
		displayFunc: TMapFunc?
		descFunc: TMapFunc?
		): string =>

	assert isPrimitive(val), "Not a primitive: #{val}"
	str := (
		  defined(displayFunc)
		? displayFunc(key, val, parent)
		: toNice(val)
		)
	return (
		  defined(descFunc)
		? f"#{str} #{descFunc(key, val, parent)}:{cyan}"
		: str
		)

# ---------------------------------------------------------------------------

export OL := (
		x: unknown,
		hOptions = {}
		): string =>

	type opt = {
		label: string?
		pos: number?
		debug: boolean
		}
	{label, pos, debug} := getOptions<opt> hOptions, {
		label: undef
		pos: undef
		debug: false
		}

	text := (
		if defined(label)
			"#{label} = #{toNice(x, {compact: true})}"
		else
			toNice(x, compact: true)
		)
	if debug
		n := Math.floor(text.length / 10) + 1
		return [
			text
			'\n'
			' '.repeat(if defined(label) then label.length + 3 else 0)
			"|         ".repeat(n)
		].join ''
	else
		return text

# ---------------------------------------------------------------------------

export ML := (x: unknown, hOptions = {}): string =>

	type opt =
		label: string?
	{label} := getOptions<opt> hOptions,
		label: undef
	if defined(label)
		return [
			sep('-', label)
			toNice(x, compact: false)
			sep('-')
		].join '\n'
	else
		return toNice x, compact: false

# ---------------------------------------------------------------------------

export DUMP := (
		x: unknown,
		label: string? = undef,
		hOptions: hash = {}
		): void =>

	type opt = {
		width: number
		char: string
		endLabel: boolean
		}
	{width, char, endLabel} := getOptions<opt> hOptions, {
		width: 64
		char: '-'
		endLabel: false
		}
	writeln sep(char, label, width)
	if isString(x)
		if nonEmpty(x)
			writeln x
	else
		writeln toNice(x, hOptions)
	writeln sep(char, (endLabel ? "END #{label}" : undef), width)
	return