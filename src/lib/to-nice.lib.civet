# to-nice.lib.civet

import {cyan, blue, black} from 'jsr:@std/fmt/colors'

import {uni, esc} from 'unicode'
import {write, writeln} from 'console-utils'
import {
	assert, croak, undef, defined, notdefined,
	hash, hashof, isString, isArray, isClass, isRegExp,
	isPrimitive, isEmpty, nonEmpty, assertIsHash, integer,
	symbolName, className, functionName, regexpDef,
	} from 'datatypes'
import {
	getOptions, o, toBlock, spaces, mapEachLine, sep,
	} from 'llutils'

# ---------------------------------------------------------------------------

export mark := (str: string): string =>

	return uni.startchar + str + uni.endchar

# ---------------------------------------------------------------------------

export type TCompareFunc = (a: string, b: string) => number

export alphaCompare: TCompareFunc := (a: string, b: string): number =>

	return if (a < b) then -1 else if (a > b) then 1 else 0

# ---------------------------------------------------------------------------

# --- any leading digit must be preceded by a single '\'

export toNiceString := (
		str: string,
		compact: boolean = true
		): string =>

	# --- escape spaces and \t, \n or \r with unicode chars
	estr := esc(str, compact ? 'oneline' : 'multiline')

	# --- precede with '“' if
	#        - starts with digit
	#        - starts with '-'
	#        - looks like a label
	if estr.match(/^[\d-]/) || estr.match(/^\.\d/)
		return uni.lsmartq + estr
	else if estr.match(///^ [^˳\s]+ \: ˳///)
		return uni.lsmartq + estr
	else
		return estr

# ---------------------------------------------------------------------------

# --- Returns a function that:
#        compares 2 strings based on their position in lSortKeys
#        else compares alphabetically
getCompareFunc := (lSortKeys: string[]): TCompareFunc =>

	# --- Create map of key to number
	h: hashof<number> := {}
	let i1 = 0
	for key of lSortKeys
		i := i1++
		h[key] = i + 1
	return function(a: string, b: string): number
		aVal := h[a]
		bVal := h[b]
		if defined(aVal)
			if defined(bVal)
				# --- compare numerically
				return (aVal < bVal) ? -1 : (aVal > bVal) ? 1 : 0
			else
				return -1
		else
			if defined(bVal)
				return 1
			else
				return alphaCompare a, b

# ---------------------------------------------------------------------------

export rotpos := <T>(lArray: T[], i: integer): T =>

	return lArray[i % lArray.length]

# ---------------------------------------------------------------------------

indented := (block: string, oneIndent: string) =>

	return mapEachLine block, (line) => oneIndent + line

# ---------------------------------------------------------------------------

export type TPathIndex = string | number
export buildPath := (lPath: TPathIndex[]): string =>

	let str = 'root'
	for item of lPath
		if isString(item)
			str += ".#{item}"
		else
			str += "[#{item.toString()}]"
	return str

# ---------------------------------------------------------------------------

export type TMapFunc = (key: string, value: unknown, hParent: hash) => unknown

export emptyMapFunc := (key: string, value: unknown, hParent: hash): unknown =>

	return undef

export toNice := (
		x: unknown,
		hOptions: hash = {},
		mapVisited: Map<object, string> = new Map<object, string>(),
		lPath: TPathIndex[] = []
		): string =>

	# --- When recoverable, classes and functions
	#     include their definitions,
	#     with escaped chars
	type opt =
		compact: boolean
		recoverable: boolean
		ignoreEmptyValues: boolean
		sortKeys: boolean
		sortFunc: TCompareFunc?
		mapFunc: TMapFunc
		lInclude: string[]?
		lExclude: string[]?
		lIndents: string[]
	{
		compact, recoverable, ignoreEmptyValues, sortKeys, sortFunc,
		mapFunc, lInclude, lExclude, lIndents
		} := getOptions<opt> hOptions, {
		compact: false
		recoverable: false
		ignoreEmptyValues: false
		sortKeys: false
		sortFunc: undef
		mapFunc: emptyMapFunc
		lInclude: undef
		lExclude: undef
		lIndents: ['   ', '❘  ']
		}

	# --- You can provide sortKeys or a sortFunc, but not both
	assert !(sortKeys && defined(sortFunc)), "Bad options"
	switch typeof x
		case 'undefined':
			return mark('undef')
		case 'boolean':
			return if x then mark('true') else mark('false')
		case 'number':
			return (
				  Number.isNaN(x)    ? mark('NaN')
				: Number.isFinite(x) ? x.toString()
				:                      ((x < 0) ? mark('neginf') : mark('inf'))
				)
		case 'bigint':
			return x.toString() + 'n'
		case 'string':
			return toNiceString x, compact
		case 'symbol':
			name := symbolName x
			if name
				return mark("symbol #{name}")
			else
				return mark("symbol")
		case 'function':
			if isClass(x)
				name := className x
				if name
					return mark("class #{name}")
				else
					return mark("class")
			else
				name := functionName x
				if name
					return mark("function #{name}")
				else
					return mark("function")
		case 'object':
			if x == null
				return mark('null')
			# --- Check if object was previously visited
			prevpath := mapVisited.get x
			if prevpath
				return mark("ref #{prevpath}")
			if isRegExp(x)
				desc := esc regexpDef x
				if desc
					return mark("regexp #{desc}")
				else
					return mark("regexp")
			if isArray(x)
				if x.length == 0
					return '[]'
				mapVisited.set x, buildPath(lPath)
				lLines := []
				let i2 = 0
				for val of x
					i := i2++
					block := toNice val, hOptions, mapVisited, [...lPath, i]
					if compact
						lLines.push block
					else if isPrimitive(val) || block.startsWith('.') || isEmpty(val)
						lLines.push "- #{block}"
					else
						lLines.push '-'
						oneIndent := rotpos<string> lIndents, lPath.length
						lLines.push indented(block, oneIndent)
				if compact
					return '[' + lLines.join(' ') + ']'
				else
					return toBlock lLines

			# --- It's an object
			if (x instanceof Set)
				results := []
				for key of x.keys()
					results.push toNice key
				lKeys := results
				return (
					if (lKeys.length == 0)
						mark("emptySet")
					else
						mark("set #{lKeys.join(' ')}")
					)
			if (x instanceof Map)
				results1 := []
				for [key, val] of x.entries()
					results1.push "#{toNice(key)}:: #{toNice(val)}"
				lLines := results1
				return lLines.join '\n'
			lKeys := Object.keys x
			if lKeys.length == 0
				return '{}'
			func: TCompareFunc? := (
				if defined(sortFunc)
					sortFunc
				else if defined(lInclude)
					getCompareFunc(lInclude)
				else if sortKeys
					alphaCompare
				else
					undef
				)
			useKey := (key: unknown): boolean =>
				if (typeof key != 'string')
					return false
				if defined(lExclude) && lExclude.includes(key)
					return false
				if defined(lInclude) && not lInclude.includes(key)
					return false
				return true
			mapVisited.set x, buildPath(lPath)
			assertIsHash x # --- will allow us to index with any string
			lLines := []
			for key of (defined(func) ? lKeys.sort(func) : lKeys).filter(useKey)
				val := x[key]
				if not ignoreEmptyValues || nonEmpty(val)
					mapped := if recoverable then undef else mapFunc(key, val, x)
					newval := mapped || val
					block := isString(mapped) ? mapped : toNice(newval, hOptions, mapVisited, [...lPath, key])
					if (
							   compact
							|| (defined(newval) && isPrimitive(newval))
							|| block.startsWith(uni.startchar)
							|| isEmpty(newval)
							)
						lLines.push "#{key}: #{block}"
					else
						lLines.push "#{key}:"
						oneIndent := rotpos<string> lIndents, lPath.length
						lLines.push indented(block, oneIndent)
			if compact
				return '{' + lLines.join(' ') + '}'
			else
				return toBlock lLines
	return "<Unknown object #{x}>"

# ---------------------------------------------------------------------------

export OL := (x: unknown, hOptions = {}): string =>

	type opt =
		label: string?
		pos: number?
		debug: boolean
	{label, pos, debug} := getOptions<opt> hOptions,
		label: undef
		pos: undef
		debug: false
	text := (
		if defined(label)
			"#{label} = #{toNice(x, {compact: true})}"
		else
			toNice(x, compact: true)
		)
	if debug
		n := Math.floor(text.length / 10) + 1
		return [
			text
			'\n'
			' '.repeat(if defined(label) then label.length + 3 else 0)
			"|         ".repeat(n)
		].join ''
	else
		return text

# ---------------------------------------------------------------------------

export ML := (x: unknown, hOptions = {}): string =>

	type opt =
		label: string?
	{label} := getOptions<opt> hOptions,
		label: undef
	if defined(label)
		return [
			sep('-', label)
			toNice(x, compact: false)
			sep('-')
		].join '\n'
	else
		return toNice x, compact: false

# ---------------------------------------------------------------------------

export DUMP := (
		x: unknown,
		label: string? = undef,
		hOptions: hash = {}
		): void =>

	type opt = {
		width: number
		char: string
		endLabel: boolean
		}
	{width, char, endLabel} := getOptions<opt> hOptions, {
		width: 64
		char: '-'
		endLabel: false
		}
	writeln sep(char, label, width)
	if isString(x)
		if nonEmpty(x)
			writeln x
	else
		writeln toNice(x, hOptions)
	writeln sep(char, (endLabel ? "END #{label}" : undef), width)
	return