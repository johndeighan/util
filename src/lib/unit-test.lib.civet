# unit-test.lib.civet

import {
	assert, assertEquals, assertStrictEquals, assertNotEquals,
	assertObjectMatch, assertStringIncludes, assertMatch,
	assertArrayIncludes,
	} from '@std/assert'

import {esc, mesc} from 'unicode'
import {
	undef, defined, notdefined, isEmpty, nonEmpty,
	array, arrayof, isArray, isHash, isString, hash, hashof,
	deepEqual, hashLike, integer, THashCompareFunc,
	THashLikeFunc, THashToStringFunc, TFilterFunc,
	normalizeCode, isFunction, isClass, functionDef, classDef,
	TVoidFunc, TVoidIterator, getErrStr,
	croak, assertIsDefined, isGenerator, isIterator,
	} from 'datatypes'
import {
	pass, o, keys, getOptions, spaces, blockToArray,
	allLinesInBlock, truncStr, sleep,
	} from 'llutils'
import {splitLine, indented} from 'indent'
import {OL, ML, DUMP} from 'to-nice'
import {TextTable} from 'text-table'
import {
	pushLogLevel, popLogLevel,
	DBG, LOG, LOGVALUE, DBGVALUE,
	INDENT, UNDENT,
	} from 'logger'
import {flag} from 'cmd-args'
import {
	relpath, mkDir, barf, getPathType, fileExt,
	isDir, clearDir,
	} from 'fsys'
import {Fetcher} from 'fetcher'
import {doParse} from 'hera-parse'
import {TPLLToken, allTokensInBlock, tokenTable, tkEOF} from 'pll'
import {civet2tsFile} from 'civet'
import {sourceLib, getNeededImportStmts} from 'symbols'
import {getTsCode, getImportCode, typeCheckTsCode} from 'typescript'
import {getMyOutsideCaller} from 'v8-stack'

stringify := JSON.stringify

# ---------------------------------------------------------------------------

getTestName := (): string =>

	pushLogLevel 'silent'
	frame := getMyOutsideCaller()
	popLogLevel()
	if defined(frame)
		{line} := frame
		DBG "TEST NAME: line #{line}"
		return "line #{line}"
	else
		return "Unknown line"

# ---------------------------------------------------------------------------

procValue := (x: unknown): unknown =>

	return (
		  Array.isArray(x) ? x
		: isGenerator(x)   ? Array.from(x())
		: isIterator(x)    ? Array.from(x)
		:                    x
		)

# ---------------------------------------------------------------------------
#      In a unit test, checks if  value is deeply equal to
#         the expected value.
#      Reports line number of the test.
#      If passed in iterator, will use Array.from() to get an array
#
#      e.g.
#      	equal 2+2, 4

export equal := (value: unknown, expected: unknown): boolean =>

	name := getTestName()
	newVal := procValue value
	newExpect := procValue expected
	DBG "equal ?, #{stringify(newExpect)} (#{name})"
	Deno.test name, () => assertEquals newVal, newExpect
	try
		assertEquals newVal, newExpect
		return true
	catch err
		return false

# ---------------------------------------------------------------------------

export same := (value: unknown, expected: unknown): void =>

	name := getTestName()
	DBG "same ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertStrictEquals value, expected
	return

# ---------------------------------------------------------------------------

export truthy := (value: unknown): void =>

	name := getTestName()
	DBG "truthy #{stringify(value)} (#{name})"
	Deno.test name, () => assert value
	return

# ---------------------------------------------------------------------------

export falsy := (value: unknown): void =>

	name := getTestName()
	DBG "falsy #{stringify(value)} (#{name})"
	Deno.test name, () => assert (not value)
	return

# ---------------------------------------------------------------------------

export fails := (func: TVoidFunc): void =>

	pushLogLevel 'silent' # --- silence any errors generated
	name := getTestName()
	DBG "fails <func> (#{name})"
	Deno.test name, : void =>
		try
			func()
			popLogLevel()
			throw new Error("Test Failure - function succeeds!!!")
		catch err
			popLogLevel()
	return

# ---------------------------------------------------------------------------

export succeeds := (func: TVoidFunc): void =>

	assert (typeof func == 'function'), "test succeeds() passed non-function"
	name := getTestName()
	DBG "succeeds <func> (#{name})"
	Deno.test name, : void =>
		try
			func()
		catch err
			errMsg := getErrStr err
			console.log errMsg
			fullErrMsg := "FAIL - func throws (#{errMsg})"
			console.log fullErrMsg
			throw new Error(fullErrMsg)
	return

# ---------------------------------------------------------------------------

export iterEqual := (
		iter: Iterable<unknown>,
		expected: unknown[]
		): void =>

	name := getTestName()
	DBG "iterEqual ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertEquals Array.from(iter), expected
	return

# ---------------------------------------------------------------------------

export iterLike := (
		iter: Iterable<hash>,
		expected: hash[]
		): void =>

	name := getTestName()
	DBG "iterEqual ?, #{stringify(expected)} (#{name})"
	lItems := Array.from iter
	len := lItems.length
	Deno.test "#{name}/len", () => assertEquals len, expected.length
	for let end = len - 1, i1 = 0, asc = 0 <= end; if asc then i1 <= end else i1 >= end; if asc then ++i1 else --i1
		i := i1
		# @ts-ignore
		Deno.test "#{name}/#{i}", () => assertObjectMatch lItems[i], expected[i]
	return

# ---------------------------------------------------------------------------

export matches := (value: unknown, expected: unknown): void =>

	assert isString(value), "Not a string: #{value}"
	name := getTestName()
	DBG "matches ?, #{stringify(expected)} (#{name})"
	if isString(expected)
		Deno.test name, () => assertStringIncludes value, expected
	else if (expected instanceof RegExp)
		Deno.test name, () => assertMatch value, expected
	else
		Deno.test name, () => assert false
	return

# ---------------------------------------------------------------------------

export like := (value: object?, expected: hash): void =>

	name := getTestName()
	DBG "like ?, #{stringify(expected)} (#{name})"
	if notdefined(value)
		Deno.test name, () => assertEquals value, undef
	else
		Deno.test name, () => assertObjectMatch value, expected
	return

# ---------------------------------------------------------------------------

export codeLike := (value: string, expected: string): void =>

	name := getTestName()
	DBG "codeLike ?, #{stringify(expected)} (#{name})"
	Deno.test name, : void =>
		assertEquals normalizeCode(value), normalizeCode(expected)
	return

# ---------------------------------------------------------------------------

export strListLike := (
		value: string[],
		expected: string[]
		): void =>

	name := getTestName()
	DBG "strListLike ?, #{stringify(expected)}"
	len := value.length
	Deno.test "#{name}/len", () => assertEquals len, expected.length
	if len == 0
		return
	lValues := value.toSorted()
	lExpected := expected.toSorted()
	for let end1 = len - 1, i2 = 0, asc1 = 0 <= end1; if asc1 then i2 <= end1 else i2 >= end1; if asc1 then ++i2 else --i2
		i := i2
		val := lValues[i]
		exp := lExpected[i]
		# @ts-ignore
		Deno.test "#{name}/#{i}", () => assertEquals val, exp
	return

# ---------------------------------------------------------------------------

export objListLike := (
		value: hash[],
		expected: hash[],
		strFunc: THashToStringFunc? = undef,
		likeFunc: THashLikeFunc = hashLike # used for comparison
		): void =>

	name := getTestName()
	DBG "objListLike ?, #{stringify(expected)}"
	DBG "strFunc is #{OL(strFunc)}"
	len := value.length
	Deno.test "#{name}/len", () => assertEquals len, expected.length
	if len == 0
		return
	# --- create the arrays to actually be compared
	let lVals: hash[] = value
	if defined(strFunc)
		compareFunc: THashCompareFunc := (a: hash, b: hash) =>
			str1 := strFunc a
			str2 := strFunc b
			return if (str1 < str2) then -1 else if (str1 > str2) then 1 else 0
		lVals = value.toSorted(compareFunc)
	nVals := lVals.length
	DBG "lVals is array of length #{nVals}"
	let lExp: hash[] = value
	if defined(strFunc)
		DBG "strFunc defined"
		compareFunc: THashCompareFunc := (a: hash, b: hash) =>
			str1 := strFunc a
			str2 := strFunc b
			return if (str1 < str2) then -1 else if (str1 > str2) then 1 else 0
		lExp = expected.toSorted(compareFunc)
	nExp := lExp.length
	DBG "lExp is array of length #{nExp}"
	for let end2 = len - 1, i3 = 0, asc2 = 0 <= end2; if asc2 then i3 <= end2 else i3 >= end2; if asc2 then ++i3 else --i3
		i := i3
		# @ts-ignore
		Deno.test "#{name}/#{i}", () => assert likeFunc lVals[i], lExp[i]
	return

# ---------------------------------------------------------------------------

export includes := (value: unknown, expected: unknown): void =>

	assert Array.isArray(value), "not an array: #{value}"
	name := getTestName()
	DBG "includes ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertArrayIncludes value, [expected]
	return

# ---------------------------------------------------------------------------

export includesAll := (value: unknown, expected: unknown): void =>
	assert Array.isArray(value), "not an array: #{value}"
	assert Array.isArray(expected), "not an array: #{expected}"
	name := getTestName()
	DBG "includesAll ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertArrayIncludes value, expected
	return

# ---------------------------------------------------------------------------
# throws on error

export checkType := (
		typeStr: string,
		value: unknown,
		expectSuccess: boolean = true
		): void =>

	valueStr := (
		  isFunction(value) ? functionDef(value)
		: isClass(value)    ? classDef(value)
		:                     JSON.stringify(value)
		)
	tsCode := getTsCode typeStr, valueStr
	DUMP tsCode, 'tsCode'

	# --- check if we need to import the type
	importCode := getImportCode typeStr
	DUMP importCode, 'importCode'

	code := """
		#{importCode}
		#{tsCode}
		"""
	DUMP code, 'code'

	errMsg := typeCheckTsCode code
	if errMsg
		croak errMsg
	return

# ---------------------------------------------------------------------------

export isType := (
		typeStr: string,
		value: unknown,
		isOfType: (Function?) = undef
		): void =>

	name := getTestName()
	if defined(isOfType)
		DBG "Using type guard"
		Deno.test name, () => assert isOfType value
	else
		DBG INDENT
		let errMsg: string? = undef
		try
			checkType typeStr, value, true
		catch err
			console.log "TYPE ERROR: #{getErrStr(err)}"
			errMsg = getErrStr(err)
		DBG UNDENT
		Deno.test name, () => assert isEmpty(errMsg)
	return

# ---------------------------------------------------------------------------

export notType := (
		typeStr: string,
		value: unknown,
		isOfType: Function? = undef
		): void =>

	name := getTestName()
	if defined(isOfType)
		DBG "Using type guard"
		Deno.test name, () => assert not isOfType(value)
	else
		DBG INDENT
		let errMsg: string? = undef
		try
			checkType typeStr, value, false
		catch err
			errMsg = getErrStr(err)
		DBG UNDENT
		Deno.test name, () => assert nonEmpty(errMsg)
	return

# ---------------------------------------------------------------------------

export type TFileOp = {
		op: 'mkDir' | 'clearDir' | 'compile'
		path: string
		}
	| {
		op: 'barf'
		path: string
		contents: string
		}

# ---------------------------------------------------------------------------

export execFileOps := (
		lFileOps: TFileOp[]
		): void =>

	for h of lFileOps
		switch h.op
			when 'mkDir'
				mkDir h.path
			when 'clearDir'
				clearDir h.path
			when 'compile'
				civet2tsFile h.path
			when 'barf'
				barf h.path, h.contents
	return

# ---------------------------------------------------------------------------
# ASYNC

export getFileOps := (desc: string): TFileOp[] =>

	lFileOps := await doParse<TFileOp[]> 'dir-tree', desc
	return lFileOps

# ---------------------------------------------------------------------------
# ASYNC

export setDirTree := (desc: string): TFileOp[] =>

	lFileOps := await getFileOps(desc)
	execFileOps lFileOps
	return lFileOps

# ---------------------------------------------------------------------------

export fileOpsTable := (
		lFileOps: TFileOp[]
		hOptions: hash = {}
		): string =>

	type opt = {
		oneLine: boolean
		trunc: number
		}
	{oneLine, trunc} := getOptions<opt> hOptions, {
		oneLine: true
		trunc: 32
		}

	tt := new TextTable("l l l")
	tt.fullsep()
	tt.title 'FILE OPS'
	tt.fullsep()
	tt.labels ['op', 'path', 'contents']
	tt.sep()
	for h of lFileOps
		switch h.op
			when 'barf'
				{path, contents} := h
				str := contents || ''
				if str.length == 0
					tt.data ['barf', path, '<empty>']
				else if oneLine
					output := truncStr(esc(str), trunc)
					tt.data ['barf', path, output]
				else
					lLines := blockToArray str
					for line,i of lLines
						contents := truncStr(esc(lLines[i]), trunc)
						if (i == 0)
							tt.data ['barf', path, contents]
						else
							tt.data ['', '', contents]
			else
				tt.data [h.op, h.path, '']
	tt.fullsep()
	return tt.asString()

# ---------------------------------------------------------------------------
# --- Create some values for testing

export sampleVal: hashof<unknown> := {
	undef: undefined
	null: null
	emptyStr: ''
	str: 'abc'
	i: 42
	f: 3.14159
	b: true
	genFunc: () ->
		yield 42
		return
	asyncGenFunc: () ->
		await sleep(1)
		yield 42
		return
	regularFunc: () ->
		return 42
	lambdaFunc: () =>
		return 42
	emptyHash: {}
	fullHash: {a: 42}
	emptyList: []
	fullList: [42]
	}

# ---------------------------------------------------------------------------
# --- Returns true only if all the named values return true
#     AND all the not named values return false

export allTrue := (
		lNames: string[],
		pred: TFilterFunc
		): boolean =>

	for name of lNames
		if not pred(sampleVal[name])
			return false
	return true

# ---------------------------------------------------------------------------
# --- Returns true only if all the named values return true

export allFalse := (
		lNames: string[],
		pred: TFilterFunc
		): boolean =>

	for name of lNames
		if pred(sampleVal[name])
			return false
	return true

# ---------------------------------------------------------------------------

export getPromiseOf := <T>(
		value: T
		sleepFor = 1
		): T ->

	await sleep(sleepFor)
	# @ts-ignore
	return value

# ---------------------------------------------------------------------------

export getRejectedPromiseOf := <T>(
		errMsg: string
		sleepFor = 1
		): never ->

	await sleep(sleepFor)
	throw new Error(errMsg)

# ---------------------------------------------------------------------------

export generateSync := <T>(
		lItems: T[],
		): Generator<T> ->

	for item of lItems
		yield item
	return

# ---------------------------------------------------------------------------

export generateAsync := <T>(
		lItems: T[],
		sleepFor = 1
		): AsyncGenerator<T> ->

	for item of lItems
		await sleep(sleepFor)
		yield item
	return
