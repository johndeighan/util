# cmd-args.lib.civet

import {
	undef, defined, notdefined, assert, croak, nonEmpty,
	hash, hashof, char, integer,
	isEmpty, isArray, isBoolean,
	isInteger, isHash, isString,
	} from 'datatypes'
import {keys, getOptions, o, spaces} from 'llutils'
import {clearScreen} from 'console-utils'
import {setLogLevel, LOG, DBG} from 'logger'
import {OL, DUMP} from 'to-nice'

hFlags: hashof<boolean> := {}
hValues: hashof<string> := {}
lNonOptions: string[] := []

doSetLogger := true # --- maybe check an env var first?
doHandleClear := true # --- maybe check an env var first?

# ---------------------------------------------------------------------------

export flag := (ch: char): boolean =>

	return (ch in hFlags) ? hFlags[ch] : false

# ---------------------------------------------------------------------------

export numNonOptions := (): number =>

	return lNonOptions.length

# ---------------------------------------------------------------------------

export nonOption := (i: integer): string? =>

	return ((i >= 0) && (i < lNonOptions.length)) ? lNonOptions[i] : undef

# ---------------------------------------------------------------------------

export allNonOptions := (): Generator<string, void, void> ->

	for str of lNonOptions
		yield str
	return

# ---------------------------------------------------------------------------

export argValue := (name: string): string? =>

	return (name in hValues) ? hValues[name] : undef

# ---------------------------------------------------------------------------

export setCmdArgs := (
		lArgs: string[] = Deno.args
		): void =>

	let i1 = 0
	for arg of lArgs
		i := i1++
		if (arg == '!') && (i == lArgs.length - 1) && doHandleClear
			clearScreen()
			continue
		if arg == '--'
			continue
		lMatches := arg.match /^-([A-Za-z0-9_-]+)(?:(=)(.*))?$/
		if lMatches == null
			lNonOptions.push arg
			continue
		[_, optStr, eqStr, valueStr] := lMatches
		if eqStr
			hValues[optStr] = valueStr
		else
			for ch of optStr.split('')
				if (ch == 'D')
					setLogLevel('debug')
				hFlags[ch] = true

setCmdArgs()

# ---------------------------------------------------------------------------

export debugging := flag 'D'
export inspecting := flag 'd'

# ---------------------------------------------------------------------------

export type TKeyDesc =
	type?: string # --- ignored for key _
	range?: [integer, integer] #     used only for key _
	desc?: string

export type TCmdDesc =
	[key: string]: TKeyDesc | string

# ---------------------------------------------------------------------------

export helpStr := (hDesc: TCmdDesc): string =>

	lLines := ['Usage:']
	for key,h in hDesc
		# @ts-ignore
		desc: string := isString(h) ? h : ('desc' in h) ? h.desc : ''
		if key == '_'
			lLines.push "   non-options: #{desc}"
		else if desc
			lLines.push "   #{key}: #{desc}"
	return lLines.join '\n'

# ---------------------------------------------------------------------------

export getCmdArgErrors := (hDesc: TCmdDesc): string? =>

	lErrors: string[] := []
	for flag of keys(hFlags)
		if !(flag in hDesc) && !(flag != 'D')
			lErrors.push "Unknown flag: #{flag}"
	for key in hValues
		value := hValues[key]
		if key in hDesc
			hKeyDesc := hDesc[key]
			# @ts-ignore
			if isHash(hKeyDesc) && ('type' in hKeyDesc)
				switch hKeyDesc.type
					when 'number'
						assert value.match(/^\d+(?:\.\d*)?$/),
								"Not a number: #{value}"
		else
			lErrors.push "Unknown var: #{key}"
	return if (lErrors.length == 0) then undef else lErrors.join('\n')

# ---------------------------------------------------------------------------
# --- Throws exception if problem found
#     Also handles -h option as help text

export checkCmdArgs := (hDesc: TCmdDesc): void =>

	if flag('h')
		LOG helpStr hDesc
		Deno.exit 0
	errMsg := getCmdArgErrors hDesc
	if defined(errMsg) && nonEmpty(errMsg)
		croak errMsg
	return