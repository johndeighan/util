# source-map.lib.civet

import {parse: parseFilePath} from 'node-path'
import {existsSync} from '@std/fs'
import {SourceMapConsumer} from 'npm-source-map'

import {
	undef, assert, defined, notdefined, hash, croak,
	assertIsDefined, assertIsString, getErrStr,
	} from 'datatypes'
import {
	getOptions, THashEntry, TEntryFilter, filterHash,
	} from 'llutils'
import {OL, DUMP} from 'to-nice'
import {LOG, DBG, ERR} from 'logger'
import {TextTable} from 'text-table'
import {
	fromJsonFile, parsePath, mkpath, normalizePath, relpath,
	toFullPath, isFile, fileExt,
	} from 'fsys'

# --- Get info about all known source maps
sourceMapPath := "C:/Users/johnd/util/sourcemaps.json"
sourceMapURL := "file:///#{sourceMapPath}"

# ---------------------------------------------------------------------------

export type RawSourceMap = {
	version: number;           # The version of the source map spec (usually 3)
	file: string;              # The generated file this map is associated with
	sources: string[];         # Array of URLs to the original source files
	names: string[];           # Array of identifiers (names) used in the mappings
	sourceRoot?: string;       # Optional: URL root for the sources
	sourcesContent?: string[]; # Content of the original source files (optional)
	mappings: string;          # The actual encoded mappings (Base64 VLQ)
	}

# ---------------------------------------------------------------------------

type TSourceMaps = {
	[path: string]: RawSourceMap
	}

let hSourceMaps: TSourceMaps = (
	if isFile(sourceMapPath)
		content := Deno.readTextFileSync(sourceMapPath)
		JSON.parse(content)
	else
		{}
	)

# --- This allows the file to be missing
# let hSourceMaps: TSourceMaps = await (() =>
# 	try
# 		{default: data} := await import(sourceMapURL, {with: {type: 'json'}})
# 		return data as TSourceMaps
# 	catch err
# 		return {}
# 	)()

# ---------------------------------------------------------------------------

export getSourceMapFor := (path: string): RawSourceMap? =>

	return hSourceMaps[path]

# ---------------------------------------------------------------------------

export numSourceMaps := (): number =>

	return Object.keys(hSourceMaps).length

# ---------------------------------------------------------------------------

export orgNumSourceMaps := numSourceMaps()

# ---------------------------------------------------------------------------

export filePosStr := (h: TFilePos): string =>

	{source, line, col} := h
	if defined(source)
		fileName := parsePath(source).fileName
		return "#{fileName}:#{line}:#{col}"
	else
		return "unknown:#{line}:#{col}"

# ---------------------------------------------------------------------------

export decodeLine := (line: string): number[][] =>

	if (line == '')
		return []

	return for token of line.split(',')
		lOutput: number[] := []
		let i = 0
		while (i < token.length)
			let v = 0, d = atob("AAA" + token[i]).charCodeAt(2)
			i += 1
			v |= (d & 31)          # put lowest 5 bits of d into v
			let shift = 5
			while (d & 32)         # repeat if high bit of d is set
				d = atob("AAA" + token[i]).charCodeAt(2)
				i += 1
				v |= (d & 31) << shift   # put lowest 5 bits of d into v
				shift += 5
			lOutput.push(v & 1 ? -(v >> 1) : v >> 1) # low bit is sign
		lOutput

# ---------------------------------------------------------------------------

export getMappings := (
		data: string,
		): number[][] =>

	lMappings: number[][] := []
	var sum: number[] = [0, 0, 0, 0]
	for line,lineNum of data.split(";")
		sum[0] = 0
		decodeLine(line).forEach (p) =>
			for (i of [0...p.length])
				sum[i] += p[i]
			lMappings.push [lineNum, sum[0], sum[1], sum[2], sum[3]]
	return lMappings

# ---------------------------------------------------------------------------

type TOrgPos = [fileNum: number, line: number, col: number]
type TCompareResult = -1 | 0 | 1

compare := (
		find: [number, number],
		gen:  [number, number]
		): TCompareResult =>

	return (
		  (find[0] < gen[0]) ? -1
		: (find[0] > gen[0]) ?  1
		: (find[1] < gen[1]) ? -1
		: (find[1] > gen[1]) ?  1
		:                       0
		)

export orgPos := (
		lMappings: number[][],
		findLine: number,
		findCol: number
		): TOrgPos =>

	assert (lMappings.length > 0), "Empty mappings array"
	let pos = 0, end = lMappings.length - 1
	while (pos <= end)

		# --- Calculate the middle index
		mid := Math.floor((pos + end) / 2)
		[genLine, genCol, orgFile, orgLine, orgCol] := lMappings[mid]
		switch compare([findLine, findCol], [genLine, genCol])
			when 0
				return [orgFile, orgLine, orgCol]
			when -1
				end = mid - 1;
			when 1
				pos = mid + 1;

	# --- If the loop finishes, the target is not in the array
	if (pos < lMappings.length)
		usePos := (pos == 0) ? pos : pos-1
		[genLine, genCol, orgFile, orgLine, orgCol] := lMappings[usePos]
		return [orgFile, orgLine, orgCol]
	else
		last := lMappings.at(-1)
		assertIsDefined last
		[genLine, genCol, orgFile, orgLine, orgCol] := last
		return [orgFile, orgLine, orgCol]

# ---------------------------------------------------------------------------

type TStrictFilePos = {
	source: string
	line: number
	col: number
	}

# --- This allows passing in a full stack frame
#     as long as it has fields source, line and col
export type TFilePos = TStrictFilePos & {
	[key: string | symbol]: unknown
	}

# ---------------------------------------------------------------------------
# --- returns undef if for any reason, it can't map

export mapSourcePos := (
		h: TFilePos,
		): TStrictFilePos? =>

	try
		{source, line, col} := h

		assert source, "EMPTY source in mapSourcePos"
		assert existsSync(source), "No such file: #{source}"

		path := toFullPath(source)
		DBG "Search for key #{path} in sourcemap.json"

		hSrcMap: RawSourceMap := hSourceMaps[path] as RawSourceMap
		assert defined(hSrcMap), "Not found in source map: #{path}"
		# @ts-ignore
		{version, sources, mappings, names} := hSrcMap as RawSourceMap
		assert (version == 3), "Bad version: #{version}"
		lMappings := getMappings(mappings)
		[fileNum, srcLine, srcCol] := orgPos(lMappings, line, col)

		DBG "   FOUND: #{source}"
		return {
			source: sources[fileNum]
			line: srcLine
			col: srcCol
			}
	catch err
		DBG "ERROR: #{getErrStr(err)}"
		return undef

# ---------------------------------------------------------------------------

export extractSourceMap := (
		contents: string
		): [string, RawSourceMap?] =>

	lMatches := contents.match ///^
			(.*)
			\/ \/ \# \s+
			sourceMappingURL=data:application\/json;
			(?:charset=utf-8;)?
			base64,
			(.+)
			$///s
	if (lMatches == null)
		return [contents, undef]
	[_, code, hSrcMapStr] := lMatches
	hSrcMap := JSON.parse(atob(hSrcMapStr)) as RawSourceMap
	{file} := hSrcMap
	if file.includes('.tsx')
		ERR "file ends with .tsx in source map"
	hSrcMap.file = relpath(file)
	hSrcMap.sources = for path of hSrcMap.sources
		relpath(path)
	return [code, hSrcMap]

# ---------------------------------------------------------------------------

export haveSourceMapFor := (path: string): boolean =>

	assert (fileExt(path) == '.ts'), "Not a .ts file: #{path}"
	return (toFullPath(path) in hSourceMaps)

# ---------------------------------------------------------------------------

export addSourceMap := (
		path: string,
		hSrcMap: RawSourceMap
		): void =>

	hSourceMaps[normalizePath(path)] = hSrcMap
	return

# ---------------------------------------------------------------------------
# ASYNC

export saveSourceMaps := (): number =>

	await Deno.writeTextFile(
		sourceMapPath
		JSON.stringify(hSourceMaps, null, 3)
		)
	return numSourceMaps()

# ---------------------------------------------------------------------------

export dumpSourceMapFor := (
		path: string
		hOptions: hash = {}
		): void =>

	type opt = {
		linesOnly: boolean
		}
	{linesOnly} := getOptions<opt> hOptions, {
		linesOnly: false
		}

	fullPath := toFullPath path
	hSrcMap := getSourceMapFor(fullPath)
	if notdefined(hSrcMap)
		LOG "There is not source map for #{path}"
		return
	assert (hSrcMap.version == 3), "Not version 3"
	assert (hSrcMap.sources.length == 1), "Multiple sources"

	lMappings := getMappings(hSrcMap.mappings)

	fmtStr := (linesOnly ? 'r r r' : 'r r r r r')
	table := new TextTable(fmtStr, {decPlaces: 0})
	table.title   relpath(hSrcMap.file)
	table.fullsep '-'
	if linesOnly
		table.labels  ['ts line', '=>', 'cv line']
		let prevLine = -1
		for item of lMappings
			[line, col, iFile, iLine, iCol] := item
			if (line != prevLine)
				table.data [line, '=>', iLine]
				prevLine = line
	else
		table.labels  ['line', 'col', '=>', 'line', 'col']
		for item of lMappings
			[line, col, iFile, iLine, iCol] := item
			table.data [line, col, '=>', iLine, iCol]
	LOG table.asString()
