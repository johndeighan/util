# compileall.lib.civet

import {red, cyan} from '@std/fmt/colors'
import {resolve, relative} from '@std/path'
import {expandGlob} from '@std/fs/expand-glob'
import {RawSourceMap, SourceMapConsumer} from 'npm:source-map'
import {compile as compileCivet} from 'npm:@danielx/civet'

import hCivetConfig from "civetconfig" with {type: "json"}

sourceMapPath := './sourcemap.json'

export undef := undefined

type TDefined = NonNullable<unknown>
export defined := (x: unknown): x is TDefined =>
	return (x != undef) && (x != null)

type TNotDefined = null | undefined
export notdefined := (x: unknown): x is TNotDefined =>
	return not defined(x)

# ---------------------------------------------------------------------------

export DUMP := (x: unknown): void =>

	console.dir x, {depth: null}
	return

# ---------------------------------------------------------------------------

export isIterator := <T>(x: unknown): x is IterableIterator<T> =>

	if (
			   (x == undef)
			|| (x == null)
			|| (typeof x != 'object')
			|| ('next' not in x)
			|| (typeof x.next != 'function')
			|| (Symbol.iterator not in x)
			)
		return false
	iter := x[Symbol.iterator]
	return (typeof iter == 'function') && (iter.call(x) == x)

# ---------------------------------------------------------------------------

export isAsyncIterator := <T>(x: unknown): x is AsyncIterableIterator<T> =>

	if (
			   (x == undef)
			|| (x == null)
			|| (typeof x != 'object')
			|| ('next' not in x)
			|| (typeof x.next != 'function')
			|| (Symbol.asyncIterator not in x)
			)
		return false
	iter := x[Symbol.asyncIterator]
	return (typeof iter == 'function') && (iter.call(x) == x)

# ---------------------------------------------------------------------------

export isPromise := <T>(x: unknown): x is Promise<T> =>

	return (
		   (typeof x == 'object')
		&& (x != null)
		&& ('then' in x)
		&& (typeof x.then == 'function')
		)

# ---------------------------------------------------------------------------

export type TMaybeCmd = 'stop' | undefined | void

# ---------------------------------------------------------------------------

export function mapper<TIn, TOut>(
		lItems:  Generator<TIn> |
					AsyncGenerator<TIn> |
					TIn[]
		mapFunc: (x: TIn, i: number) =>
			TOut? |
			Promise<TOut?> |
			Generator<TOut, TMaybeCmd> |
			AsyncGenerator<TOut, TMaybeCmd>
		): AsyncGenerator<TOut>

	# --- NOTE: You can await something even if it's not async
	for await item,i of lItems
		iter := mapFunc item, i
		if isIterator(iter) || isAsyncIterator(iter)
			loop
				{done, value} := await iter.next()
				if done
					if (value == 'stop')  # value returned from mapFunc()
						return
					else
						break
				else if (value != undefined)
					yield value
		else if (iter != undefined)
			if isPromise(iter)
				# --- iter is a TOut
				result := await iter
				if (result != undefined)
					yield result
			else
				yield iter
	return

# ---------------------------------------------------------------------------

export reducer := <TIn, TAccum>(
		lItems: Generator<TIn> |
				AsyncGenerator<TIn> |
				TIn[]
		acc: TAccum
		redFunc: (acc: TAccum, x: TIn, i: number) =>
			TAccum? |
			Promise<TAccum?> |
			Generator<TAccum, TMaybeCmd> |
			AsyncGenerator<TAccum, TMaybeCmd>
		): TAccum ->

	for await item,i of lItems
		iter := redFunc acc, item, i
		if isIterator(iter) || isAsyncIterator(iter)
			loop
				{done, value} := await iter.next()
				if done
					if (value == 'stop')
						return await acc
					else
						break
				else if (value != undefined)
					acc = value
		else if (iter != undefined)
			if isPromise(iter)
				result := await iter
				if (result != undefined)
					acc = result
			else
				acc = iter
	return await acc

# ---------------------------------------------------------------------------

export type TAssertFunc = (
		cond: unknown,
		msg?: string
		) => asserts cond

export assert: TAssertFunc := (
		cond: unknown,
		msg: string = "An error occurred"
		): asserts cond =>

	if not cond
		throw new Error(msg)
	return

# ---------------------------------------------------------------------------

type TSourceMaps = {
	[path: string]: RawSourceMap
	}

hSourceMaps: TSourceMaps := await (() =>
	try
		{default: data} := await import(sourceMapPath, {with: {type: 'json'}})
			# --- Or 'assert: { type: "json" }' depending on Deno version
		return data as TSourceMaps
	catch err
		return {}
	)()


# ---------------------------------------------------------------------------

# --- if verbose, output info about each civet file
#     else, only ouput errors & files actually compiled and type checked
export verbose: boolean := false

export encoder := new TextEncoder()

# ---------------------------------------------------------------------------

export encode := (str: string) =>

	return encoder.encode(str)

# ---------------------------------------------------------------------------

export LOG := (msg: string, level: number = 0): void =>

	console.log '   '.repeat(level) + msg
	return

# ---------------------------------------------------------------------------

export ERR := (msg: string, level: number = 0): void =>

	console.log '   '.repeat(level) + red(msg)
	return

# ---------------------------------------------------------------------------

export DBG := (msg: string, level: number = 0): void =>

	if verbose
		console.log '   '.repeat(level) + msg
	return

# ---------------------------------------------------------------------------

export croak := (msg: string): never =>

	throw new Error(msg)

# ---------------------------------------------------------------------------

export centered := (
		label: string,
		width: number = 64
		char: string = '-'
		): string =>

	totSpaces := width - label.length
	numLeft := Math.floor totSpaces / 2
	numRight := totSpaces - numLeft
	buf := '  '
	left := '='.repeat numLeft - 2
	right := '='.repeat numRight - 2
	return left + buf + cyan(label) + buf + right

# ---------------------------------------------------------------------------

export getErrStr := (err: unknown): string =>

	if (typeof err == 'string')
		return err
	else if (err instanceof Error)
		return err.message
	else
		return "Serious Error"

# ---------------------------------------------------------------------------

export isDir := (path: string): boolean =>

	try
		return Deno.statSync(path).isDirectory
	catch err
		if (err instanceof Deno.errors.NotFound)
			return false
		else
			throw err

# ---------------------------------------------------------------------------

export isFile := (path: string): boolean =>

	try
		return Deno.statSync(path).isFile
	catch err
		if (err instanceof Deno.errors.NotFound)
			return false
		else
			throw err

# ---------------------------------------------------------------------------

export normalizePath := (path: string): string =>

	return path.replace(/^c:/, 'C:').replaceAll('\\', '/')

# ---------------------------------------------------------------------------

export toFullPath := (path: string): string =>

	return normalizePath(resolve('.', path))

# ---------------------------------------------------------------------------

export alreadyCompiled := (civetPath: string): boolean =>

	try
		assert civetPath.endsWith('.civet')
		assert isFile(civetPath)
		tsPath := civetPath.replace('.civet', '.ts')
		assert isFile(tsPath)

		civetModTime := Deno.statSync(civetPath).mtime
		assert (civetModTime != null)
		tsModTime := Deno.statSync(tsPath).mtime
		assert (tsModTime != null)

		return (tsModTime > civetModTime)
	catch err
		return false

# ---------------------------------------------------------------------------

hGlobOptions := {
	exclude: [
		'src/temp/*'
		'src/save/*'
		'src/test/**/*'
		]
	}

# ---------------------------------------------------------------------------
# ASYNC

export allCivetFiles := (): AsyncGenerator<string> ->

	path := Deno.args[0]
	if path
		assert isFile path
		yield path
	else
		for await {path} of expandGlob("src/**/*.civet", hGlobOptions)
			yield path
	return

# ---------------------------------------------------------------------------
# ASYNC - just returns true or false, stdout & stderr 'inherit'

execCmd := (
		cmdName: string
		lArgs: string[] = []
		): boolean =>

	cmd := new Deno.Command cmdName, {args: lArgs}
	child := cmd.spawn()
	{success} := await child.status
	return success

# ---------------------------------------------------------------------------
# ASYNC - just returns true or false

export typeCheck := (path: string): boolean =>

	return await execCmd 'deno', ['check', path]

# ---------------------------------------------------------------------------

export haveSourceMapFor := (path: string): boolean =>

	return (toFullPath(path) in hSourceMaps)

# ---------------------------------------------------------------------------

export addSourceMap := (
		path: string,
		hSrcMap: RawSourceMap
		): void =>

	hSourceMaps[normalizePath(path)] = hSrcMap
	return

# ---------------------------------------------------------------------------

export extractSourceMap := (
		contents: string
		): [string, RawSourceMap?] =>

	lMatches := contents.match ///^
			(.*)
			\/ \/ \# \s+
			sourceMappingURL=data:application\/json;
			(?:charset=utf-8;)?
			base64,
			(.+)
			$///s
	if (lMatches == null)
		return [contents, undefined]
	code := lMatches[1].trim()
	hSrcMap := JSON.parse(atob(lMatches[2].trim())) as RawSourceMap
	{file} := hSrcMap
	hSrcMap.file = normalizePath(file.replace('.tsx', '.ts'))
	hSrcMap.sources = for path of hSrcMap.sources
		normalizePath(path)
	return [code, hSrcMap]

# ---------------------------------------------------------------------------
# ASYNC

export saveSourceMaps := (): void =>

	await Deno.writeTextFile(
		sourceMapPath
		JSON.stringify(hSourceMaps, null, 3)
		)
	return

# ---------------------------------------------------------------------------

# export type TStatus = 'ok' | 'error' | 'alreadyCompiled'
# export type TResult = {
# 		status: TStatus
# 		destPath: string
# 		code: string
# 		hSrcMap: RawSourceMap
# 		}

export type TOkResult = {
	status: 'ok'
	destPath: string
	code: string
	hSrcMap: RawSourceMap
	}

export type TResult = TOkResult |
	{
		status: 'error'
		destPath: string
		errMsg: string
		} |
	{
		status: 'alreadyCompiled'
		destPath: string
		}

# ---------------------------------------------------------------------------
# --- ASYNC GENERATOR

export compileCivetFile := (
		path: string
		): AsyncGenerator<TResult, void, void> ->

	civetPath := toFullPath path
	relPath := relative('.', civetPath)
	destPath := civetPath.replace('.civet', '.ts')
	relDestPath := relative('.', destPath)

	if alreadyCompiled(path)
		DBG centered("COMPILE: #{relPath}")
		DBG "already compiled to #{relDestPath}", 1
		yield {
			status: 'alreadyCompiled'
			destPath
			}
		return

	try
		LOG centered("COMPILE: #{relPath}")
		LOG "destPath = #{relDestPath}", 1

		civetCode := await Deno.readTextFile civetPath
		tsCode: string := await compileCivet civetCode, {
			...hCivetConfig
			inlineMap: true
			filename: civetPath
			}
		assert tsCode && not tsCode.startsWith('COMPILE FAILED'),
			"CIVET COMPILE FAILED: #{relPath}"
		[code, hSrcMap] := extractSourceMap tsCode
		assert (hSrcMap != undef), "Missing source map"
		await Deno.writeTextFile destPath, code
		addSourceMap destPath, hSrcMap
		LOG "compile OK, wrote #{relDestPath}, source map added", 1
		yield {
			status: 'ok'
			destPath
			code
			hSrcMap
			}

	catch err
		ERR "ERROR in #{relDestPath}:\n#{err}"
		yield {
			status: 'error'
			destPath
			errMsg: getErrStr(err)
			}
	return

# ---------------------------------------------------------------------------
# --- ASYNC

export typeCheckTsFile := (h: TOkResult, i: number): boolean? =>

	{destPath, code, hSrcMap} := h
	relDestPath := relative '.', destPath
	LOG centered("TYPE CHECK: #{relDestPath}")
	try
		success := await typeCheck destPath
		assert success, "type check failed for #{relDestPath}"

		LOG "type check OK", 1
		addSourceMap destPath, hSrcMap
		return true

	catch err
		ERR "ERROR in #{relDestPath}:\n#{getErrStr(err)}"
		return false

# ---------------------------------------------------------------------------
