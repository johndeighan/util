# compileall.lib.civet

import {red, cyan} from '@std/fmt/colors'
import {resolve, relative} from '@std/path'
import {expandGlob} from '@std/fs/expand-glob'
import {RawSourceMap, SourceMapConsumer} from 'source-map'

import {
	ITERATOR, ASYNC_ITERATOR, mapper, reducer,
	} from 'var-free'

sourceMapPath := './sourcemap.json'

export undef := undefined

# ---------------------------------------------------------------------------

export type TAssertFunc = (
		cond: unknown,
		msg?: string
		) => asserts cond

export assert: TAssertFunc := (
		cond: unknown,
		msg: string = "An error occurred"
		): asserts cond =>

	if not cond
		throw new Error(msg)
	return

# ---------------------------------------------------------------------------

type TSourceMaps = {
	[path: string]: RawSourceMap
	}

hSourceMaps: TSourceMaps := await (() =>
	try
		{default: data} := await import(sourceMapPath, {with: {type: 'json'}})
			# --- Or 'assert: { type: "json" }' depending on Deno version
		return data as TSourceMaps
	catch err
		return {}
	)()


# ---------------------------------------------------------------------------

# --- if verbose, output info about each civet file
#     else, only ouput errors & files actually compiled and type checked
export verbose: boolean := false

export encoder := new TextEncoder()

# ---------------------------------------------------------------------------

export encode := (str: string) =>

	return encoder.encode(str)

# ---------------------------------------------------------------------------

export LOG := (msg: string, level: number = 0): void =>

	console.log '   '.repeat(level) + msg
	return

# ---------------------------------------------------------------------------

export DBG := (msg: string, level: number = 0): void =>

	if verbose
		console.log '   '.repeat(level) + msg
	return

# ---------------------------------------------------------------------------

export croak := (msg: string): never =>

	throw new Error(msg)

# ---------------------------------------------------------------------------

export centered := (
		label: string,
		width: number = 64
		char: string = '-'
		): string =>

	totSpaces := width - label.length
	numLeft := Math.floor totSpaces / 2
	numRight := totSpaces - numLeft
	buf := '  '
	left := '='.repeat numLeft - 2
	right := '='.repeat numRight - 2
	return left + buf + cyan(label) + buf + right

# ---------------------------------------------------------------------------

export getErrStr := (err: unknown): string =>

	if (typeof err == 'string')
		return err
	else if (err instanceof Error)
		return err.message
	else
		return "Serious Error"

# ---------------------------------------------------------------------------

export isDir := (path: string): boolean =>

	try
		return Deno.statSync(path).isDirectory
	catch err
		if (err instanceof Deno.errors.NotFound)
			return false
		else
			throw err

# ---------------------------------------------------------------------------

export isFile := (path: string): boolean =>

	try
		return Deno.statSync(path).isFile
	catch err
		if (err instanceof Deno.errors.NotFound)
			return false
		else
			throw err

# ---------------------------------------------------------------------------

export normalizePath := (path: string): string =>

	return path.replace(/^c:/, 'C:').replaceAll('\\', '/')

# ---------------------------------------------------------------------------

export toFullPath := (path: string): string =>

	return normalizePath(resolve('.', path))

# ---------------------------------------------------------------------------

export alreadyCompiled := (civetPath: string): boolean =>

	try
		assert civetPath.endsWith('.civet')
		assert isFile(civetPath)
		tsPath := civetPath.replace('.civet', '.ts')
		assert isFile(tsPath)

		civetModTime := Deno.statSync(civetPath).mtime
		assert (civetModTime != null)
		tsModTime := Deno.statSync(tsPath).mtime
		assert (tsModTime != null)

		return (tsModTime > civetModTime)
	catch err
		return false

# ---------------------------------------------------------------------------

hGlobOptions := {
	exclude: [
		'src/temp/*'
		'src/save/*'
		'src/test/**/*'
		]
	}

export allCivetFiles := (): ASYNC_ITERATOR<string> ->
	path := Deno.args[0]
	if path
		assert isFile path
		yield path
	else
		for await {path} of expandGlob("src/**/*.civet", hGlobOptions)
			yield path
	return

# ---------------------------------------------------------------------------
# ASYNC - just returns true or false, stdout & stderr 'inherit'

execCmd := (
		cmdName: string
		lArgs: string[] = []
		): boolean =>

	cmd := new Deno.Command cmdName, {args: lArgs}
	child := cmd.spawn()
	{success} := await child.status
	return success

# ---------------------------------------------------------------------------
# ASYNC - just returns true or false

export typeCheck := (path: string): boolean =>

	return await execCmd 'deno', ['check', path]

# ---------------------------------------------------------------------------

export haveSourceMapFor := (path: string): boolean =>

	return (toFullPath(path) in hSourceMaps)

# ---------------------------------------------------------------------------

export addSourceMap := (
		path: string,
		hSrcMap: RawSourceMap
		): void =>

	hSourceMaps[normalizePath(path)] = hSrcMap
	return

# ---------------------------------------------------------------------------

export extractSourceMap := (
		contents: string
		): [string, RawSourceMap?] =>

	lMatches := contents.match ///^
			(.*)
			\/ \/ \# \s+
			sourceMappingURL=data:application\/json;
			(?:charset=utf-8;)?
			base64,
			(.+)
			$///s
	if (lMatches == null)
		return [contents, undefined]
	code := lMatches[1].trim()
	hSrcMap := JSON.parse(atob(lMatches[2].trim())) as RawSourceMap
	{file} := hSrcMap
	hSrcMap.file = normalizePath(file.replace('.tsx', '.ts'))
	hSrcMap.sources = for path of hSrcMap.sources
		normalizePath(path)
	return [code, hSrcMap]

# ---------------------------------------------------------------------------
# ASYNC

export saveSourceMaps := (): void =>

	await Deno.writeTextFile(
		sourceMapPath
		JSON.stringify(hSourceMaps, null, 3)
		)
	return

# ---------------------------------------------------------------------------

