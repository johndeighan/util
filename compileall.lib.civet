# compileall.lib.civet

import {red, cyan} from '@std/fmt/colors'
import {resolve, relative} from '@std/path'
import {expandGlob} from '@std/fs/expand-glob'
import {RawSourceMap, SourceMapConsumer} from 'npm:source-map'
import {compile as compileCivet} from 'npm:@danielx/civet'

import {TIterator, TAsyncIterator} from 'datatypes'
import {mapper, reducer} from 'var-free'

import hCivetConfig from "civetconfig" with {type: "json"}

sourceMapPath := './sourcemap.json'

export undef := undefined

# ---------------------------------------------------------------------------

export type TAssertFunc = (
		cond: unknown,
		msg?: string
		) => asserts cond

export assert: TAssertFunc := (
		cond: unknown,
		msg: string = "An error occurred"
		): asserts cond =>

	if not cond
		throw new Error(msg)
	return

# ---------------------------------------------------------------------------

type TSourceMaps = {
	[path: string]: RawSourceMap
	}

hSourceMaps: TSourceMaps := await (() =>
	try
		{default: data} := await import(sourceMapPath, {with: {type: 'json'}})
			# --- Or 'assert: { type: "json" }' depending on Deno version
		return data as TSourceMaps
	catch err
		return {}
	)()


# ---------------------------------------------------------------------------

# --- if verbose, output info about each civet file
#     else, only ouput errors & files actually compiled and type checked
export verbose: boolean := false

export encoder := new TextEncoder()

# ---------------------------------------------------------------------------

export encode := (str: string) =>

	return encoder.encode(str)

# ---------------------------------------------------------------------------

export LOG := (msg: string, level: number = 0): void =>

	console.log '   '.repeat(level) + msg
	return

# ---------------------------------------------------------------------------

export ERR := (msg: string, level: number = 0): void =>

	console.log '   '.repeat(level) + red(msg)
	return

# ---------------------------------------------------------------------------

export DBG := (msg: string, level: number = 0): void =>

	if verbose
		console.log '   '.repeat(level) + msg
	return

# ---------------------------------------------------------------------------

export croak := (msg: string): never =>

	throw new Error(msg)

# ---------------------------------------------------------------------------

export centered := (
		label: string,
		width: number = 64
		char: string = '-'
		): string =>

	totSpaces := width - label.length
	numLeft := Math.floor totSpaces / 2
	numRight := totSpaces - numLeft
	buf := '  '
	left := '='.repeat numLeft - 2
	right := '='.repeat numRight - 2
	return left + buf + cyan(label) + buf + right

# ---------------------------------------------------------------------------

export getErrStr := (err: unknown): string =>

	if (typeof err == 'string')
		return err
	else if (err instanceof Error)
		return err.message
	else
		return "Serious Error"

# ---------------------------------------------------------------------------

export isDir := (path: string): boolean =>

	try
		return Deno.statSync(path).isDirectory
	catch err
		if (err instanceof Deno.errors.NotFound)
			return false
		else
			throw err

# ---------------------------------------------------------------------------

export isFile := (path: string): boolean =>

	try
		return Deno.statSync(path).isFile
	catch err
		if (err instanceof Deno.errors.NotFound)
			return false
		else
			throw err

# ---------------------------------------------------------------------------

export normalizePath := (path: string): string =>

	return path.replace(/^c:/, 'C:').replaceAll('\\', '/')

# ---------------------------------------------------------------------------

export toFullPath := (path: string): string =>

	return normalizePath(resolve('.', path))

# ---------------------------------------------------------------------------

export alreadyCompiled := (civetPath: string): boolean =>

	try
		assert civetPath.endsWith('.civet')
		assert isFile(civetPath)
		tsPath := civetPath.replace('.civet', '.ts')
		assert isFile(tsPath)

		civetModTime := Deno.statSync(civetPath).mtime
		assert (civetModTime != null)
		tsModTime := Deno.statSync(tsPath).mtime
		assert (tsModTime != null)

		return (tsModTime > civetModTime)
	catch err
		return false

# ---------------------------------------------------------------------------

hGlobOptions := {
	exclude: [
		'src/temp/*'
		'src/save/*'
		'src/test/**/*'
		]
	}

export allCivetFiles := (): TAsyncIterator<string> ->
	path := Deno.args[0]
	if path
		assert isFile path
		yield path
	else
		for await {path} of expandGlob("src/**/*.civet", hGlobOptions)
			yield path
	return

# ---------------------------------------------------------------------------
# ASYNC - just returns true or false, stdout & stderr 'inherit'

execCmd := (
		cmdName: string
		lArgs: string[] = []
		): boolean =>

	cmd := new Deno.Command cmdName, {args: lArgs}
	child := cmd.spawn()
	{success} := await child.status
	return success

# ---------------------------------------------------------------------------
# ASYNC - just returns true or false

export typeCheck := (path: string): boolean =>

	return await execCmd 'deno', ['check', path]

# ---------------------------------------------------------------------------

export haveSourceMapFor := (path: string): boolean =>

	return (toFullPath(path) in hSourceMaps)

# ---------------------------------------------------------------------------

export addSourceMap := (
		path: string,
		hSrcMap: RawSourceMap
		): void =>

	hSourceMaps[normalizePath(path)] = hSrcMap
	return

# ---------------------------------------------------------------------------

export extractSourceMap := (
		contents: string
		): [string, RawSourceMap?] =>

	lMatches := contents.match ///^
			(.*)
			\/ \/ \# \s+
			sourceMappingURL=data:application\/json;
			(?:charset=utf-8;)?
			base64,
			(.+)
			$///s
	if (lMatches == null)
		return [contents, undefined]
	code := lMatches[1].trim()
	hSrcMap := JSON.parse(atob(lMatches[2].trim())) as RawSourceMap
	{file} := hSrcMap
	hSrcMap.file = normalizePath(file.replace('.tsx', '.ts'))
	hSrcMap.sources = for path of hSrcMap.sources
		normalizePath(path)
	return [code, hSrcMap]

# ---------------------------------------------------------------------------
# ASYNC

export saveSourceMaps := (): void =>

	await Deno.writeTextFile(
		sourceMapPath
		JSON.stringify(hSourceMaps, null, 3)
		)
	return

# ---------------------------------------------------------------------------

export type TOkResult = {
		destPath: string
		code: string
		hSrcMap: RawSourceMap
		}

# ---------------------------------------------------------------------------
# --- ASYNC GENERATOR

export compileCivetFile := (
		path: string
		): TAsyncIterator<TOkResult, void> ->

	civetPath := toFullPath path
	relPath := relative('.', civetPath)
	destPath := civetPath.replace('.civet', '.ts')
	relDestPath := relative('.', destPath)

	if alreadyCompiled(path)
		DBG centered("COMPILE: #{relPath}")
		DBG "already compiled to #{relDestPath}", 1
		return

	try
		LOG centered("COMPILE: #{relPath}")
		LOG "destPath = #{relDestPath}", 1

		civetCode := await Deno.readTextFile civetPath
		tsCode: string := await compileCivet civetCode, {
			...hCivetConfig
			inlineMap: true
			filename: civetPath
			}
		assert tsCode && not tsCode.startsWith('COMPILE FAILED'),
			"CIVET COMPILE FAILED: #{relPath}"
		LOG "compile succeeded", 1
		[code, hSrcMap] := extractSourceMap tsCode
		assert (hSrcMap != undef), "Missing source map"
		yield {
			destPath
			code
			hSrcMap
			}

	catch err
		ERR "ERROR in #{relDestPath}:\n#{err}"
	return

# ---------------------------------------------------------------------------
# --- ASYNC

export typeCheckTsFile := (
		hResult: TOkResult
		): boolean =>

	{destPath, code, hSrcMap} := hResult
	relDestPath := relative '.', destPath
	LOG centered("TYPE CHECK: #{relDestPath}")
	try
		# --- Unfortunately, we have to write the code to a file
		#     in order to type check it :-(

		tempPath := 'src/temp/_tempcode_.ts'
		encoded := encoder.encode(code)
		await Deno.writeFile tempPath, encoded
		success := await typeCheck tempPath
		assert success, "type check failed for #{relDestPath}"

		await Deno.writeFile destPath, encoded
		LOG "TS file written", 1
		LOG "type check OK", 1
		LOG "adding source map for #{relDestPath}", 1
		addSourceMap destPath, hSrcMap
		return true

	catch err
		ERR "ERROR in #{relDestPath}:\n#{getErrStr(err)}"
		return false

# ---------------------------------------------------------------------------
